<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>U7's Waterfall - Rugby Fixtures</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;
        
        const Calendar = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="16" y1="2" x2="16" y2="6"></line>
                <line x1="8" y1="2" x2="8" y2="6"></line>
                <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>
        );
        
        const MapPin = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
            </svg>
        );
        
        const Search = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
            </svg>
        );
        
        const RefreshCw = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        );
        
        const Eye = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>
        );
        
        const Download = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        );

        const JSONBIN_API_KEY = '$2a$10$/1IjctFCm8nvzrKEAH/KOO3MO6Jj090RnDWC3dxIFwfT2wBgC6.EO';
        const JSONBIN_BIN_ID = '698c5fe3ae596e708f2250a9';

        window.storage = {
            get: async function(key) {
                try {
                    const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}/latest`, {
                        method: 'GET',
                        headers: {
                            'X-Access-Key': JSONBIN_API_KEY
                        }
                    });
                    
                    if (!response.ok) {
                        console.error('Failed to load from JSONBin:', response.status);
                        return null;
                    }
                    
                    const result = await response.json();
                    console.log('Loaded from JSONBin:', result.record);
                    return { key, value: JSON.stringify(result.record) };
                } catch (err) {
                    console.error('Error loading fixtures:', err);
                    return null;
                }
            },
            set: async function(key, value) {
                try {
                    const data = JSON.parse(value);
                    console.log('Saving to JSONBin:', data);
                    
                    const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Access-Key': JSONBIN_API_KEY
                        },
                        body: JSON.stringify(data)
                    });
                    
                    if (!response.ok) {
                        console.error('Failed to save to JSONBin:', response.status);
                        return null;
                    }
                    
                    const result = await response.json();
                    console.log('Saved to JSONBin successfully:', result);
                    return { key, value };
                } catch (err) {
                    console.error('Error saving fixtures:', err);
                    return null;
                }
            },
            delete: async function(key) {
                return { key, deleted: true };
            }
        };

        const RugbyFixtureApp = () => {
          const urlParams = new URLSearchParams(window.location.search);
          const initialView = urlParams.get('view') === 'public' ? 'public' : 'admin';
          
          const [view, setView] = useState(initialView);
          const [teams, setTeams] = useState([]);
          const [fixtures, setFixtures] = useState([]);
          const [zones, setZones] = useState([]);
          const [searchTerm, setSearchTerm] = useState('');
          const [selectedTeam, setSelectedTeam] = useState(null);
          const [numPitches, setNumPitches] = useState(16);
          const [matchDuration, setMatchDuration] = useState(15);
          const [startTime, setStartTime] = useState('10:30');
          const [numRounds, setNumRounds] = useState(7);
          const [loading, setLoading] = useState(false);
          const [error, setError] = useState('');
          const [sheetUrl, setSheetUrl] = useState('https://docs.google.com/spreadsheets/d/13iFBeez2r61o2ZnvWrQhHz0lXLMkIa5qwj92hSkjUX0/edit?usp=sharing');
          const [loadingSheet, setLoadingSheet] = useState(false);
          const [uploadMethod, setUploadMethod] = useState('url');
          const [lunchEnabled, setLunchEnabled] = useState(true);
          const [lunchStart, setLunchStart] = useState('11:45');
          const [lunchEnd, setLunchEnd] = useState('12:30');
          const [isAuthenticated, setIsAuthenticated] = useState(false);
          const [passwordInput, setPasswordInput] = useState('');

          useEffect(() => {
            loadFixtures();
          }, []);

          const loadFixtures = async () => {
            try {
              const result = await window.storage.get('rugby-fixtures');
              if (result && result.value) {
                const data = JSON.parse(result.value);
                if (data.fixtures && data.fixtures.length > 0) {
                  setFixtures(data.fixtures || []);
                  
                  const teamMap = new Map();
                  data.fixtures.forEach(f => {
                    if (!teamMap.has(f.team1.id)) {
                      teamMap.set(f.team1.id, f.team1);
                    }
                    if (!teamMap.has(f.team2.id)) {
                      teamMap.set(f.team2.id, f.team2);
                    }
                  });
                  setTeams(Array.from(teamMap.values()));

                  if (data.zones && data.zones.length > 0) {
                    const restoredZones = data.zones.map(z => ({
                      id: z.id,
                      pitches: z.pitches,
                      teams: z.teamIds.map(id => teamMap.get(id)).filter(Boolean),
                    }));
                    setZones(restoredZones);
                  }
                }
              }
            } catch (error) {
              console.log('No existing fixtures found');
            }
          };

          const saveFixtures = async (fixtureData, teamData, zoneData) => {
            try {
              console.log('Attempting to save fixtures...', fixtureData.length);
              const payload = {
                fixtures: fixtureData,
                teams: teamData,
                zones: zoneData ? zoneData.map(z => ({ id: z.id, pitches: z.pitches, teamIds: z.teams.map(t => t.id) })) : [],
                generated: new Date().toISOString()
              };
              console.log('Payload:', payload);
              
              const result = await window.storage.set('rugby-fixtures', JSON.stringify(payload));
              console.log('Save result:', result);
              
              if (!result) {
                console.error('Failed to save - no result returned');
              } else {
                console.log('Successfully saved fixtures');
              }
            } catch (error) {
              console.error('Error saving fixtures:', error);
            }
          };
            const loadTeamsFromCSV = (csvText) => {
            const lines = csvText.split('\n');
            const loadedTeams = [];
            
            for (let i = 1; i < lines.length; i++) {
              const line = lines[i].trim();
              if (!line) continue;
              
              const columns = line.split(',').map(col => col.replace(/^"|"$/g, '').trim());
              
              const clubName = columns[0];
              const numTeams = parseInt(columns[1]) || 0;
              
              for (let t = 0; t < numTeams && t < 5; t++) {
                const teamName = columns[2 + t];
                if (teamName && teamName.trim() !== '') {
                  loadedTeams.push({
                    id: `team-${loadedTeams.length}`,
                    name: teamName.trim(),
                    club: clubName,
                    pitchAssignment: null
                  });
                }
              }
            }
            
            return loadedTeams;
          };

          const handleFileUpload = (event) => {
            setLoadingSheet(true);
            setError('');
            
            const file = event.target.files[0];
            if (!file) {
              setLoadingSheet(false);
              return;
            }
            
            const reader = new FileReader();
            reader.onload = async (e) => {
              try {
                const data = e.target.result;
                let loadedTeams = [];
                
                if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                  if (!window.XLSX) {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                    await new Promise((resolve, reject) => {
                      script.onload = resolve;
                      script.onerror = reject;
                      document.head.appendChild(script);
                    });
                  }
                  
                  const workbook = window.XLSX.read(data, { type: 'array' });
                  const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                  const csvText = window.XLSX.utils.sheet_to_csv(firstSheet);
                  
                  loadedTeams = loadTeamsFromCSV(csvText);
                } else {
                  const csvText = new TextDecoder().decode(data);
                  loadedTeams = loadTeamsFromCSV(csvText);
                }
                
                if (loadedTeams.length === 0) {
                  throw new Error('No teams found in file');
                }
                
                setTeams(loadedTeams);
                setError(`Successfully loaded ${loadedTeams.length} teams from ${new Set(loadedTeams.map(t => t.club)).size} clubs`);
              } catch (err) {
                setError('Error reading file: ' + err.message);
                console.error(err);
              }
              setLoadingSheet(false);
            };
            
            reader.onerror = () => {
              setError('Error reading file');
              setLoadingSheet(false);
            };
            
            if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
              reader.readAsArrayBuffer(file);
            } else {
              reader.readAsText(file);
            }
          };

          const loadTeamsFromSheet = async () => {
            setLoadingSheet(true);
            setError('');
            
            try {
              let sheetId = '';
              const urlMatch = sheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
              if (urlMatch) {
                sheetId = urlMatch[1];
              } else {
                throw new Error('Invalid Google Sheets URL');
              }
              
              const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
              
              const response = await fetch(csvUrl, {
                method: 'GET',
                mode: 'cors'
              });
              
              if (!response.ok) {
                throw new Error('Failed to fetch sheet');
              }
              
              const csvText = await response.text();
              const loadedTeams = loadTeamsFromCSV(csvText);
              
              if (loadedTeams.length === 0) {
                throw new Error('No teams found in sheet');
              }
              
              setTeams(loadedTeams);
              setError(`Successfully loaded ${loadedTeams.length} teams from ${new Set(loadedTeams.map(t => t.club)).size} clubs`);
              
            } catch (err) {
              setError('Error loading sheet: ' + err.message);
              console.error(err);
            }
            
            setLoadingSheet(false);
          };

          const generateSampleTeams = () => {
            const clubs = ['Rovers', 'United', 'Wasps', 'Tigers', 'Saints', 'Warriors', 'Chiefs', 'Dragons'];
            const sampleTeams = [];
            
            for (let i = 0; i < 64; i++) {
              const clubIndex = Math.floor(i / 8);
              const teamNumber = (i % 8) + 1;
              sampleTeams.push({
                id: `team-${i}`,
                name: `${clubs[clubIndex]} U7 Team ${teamNumber}`,
                club: clubs[clubIndex],
                pitchAssignment: null
              });
            }
            
            return sampleTeams;
          };

          const isLunchTime = (time) => {
            if (!lunchEnabled) return false;
            return time >= lunchStart && time < lunchEnd;
          };

          const getNextAvailableTime = (time) => {
            if (isLunchTime(time)) {
              return lunchEnd;
            }
            return time;
          };

          const addMinutes = (time, mins) => {
            const [h, m] = time.split(':').map(Number);
            const total = h * 60 + m + mins;
            return `${String(Math.floor(total / 60)).padStart(2, '0')}:${String(total % 60).padStart(2, '0')}`;
          };

          const computePitchGrid = (totalPitches, numColumns = 4) => {
            const pitchesPerColumn = Math.ceil(totalPitches / numColumns);
            const positions = {};
            let pitchNum = 1;
            for (let col = 0; col < numColumns && pitchNum <= totalPitches; col++) {
              for (let row = 0; row < pitchesPerColumn && pitchNum <= totalPitches; row++) {
                const actualRow = (col % 2 === 0)
                  ? (pitchesPerColumn - 1 - row)
                  : row;
                positions[pitchNum] = [actualRow, col];
                pitchNum++;
              }
            }
            return positions;
          };

          const computeZones = (totalPitches) => {
            const numZones = Math.floor(totalPitches / 2);
            const zoneLabels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const zoneList = [];
            for (let z = 0; z < numZones; z++) {
              zoneList.push({
                id: zoneLabels[z],
                pitches: [z * 2 + 1, z * 2 + 2],
                teams: [],
              });
            }
            return zoneList;
          };

          const computeZoneAdjacency = (zoneList, pitchGrid) => {
            const zoneCenters = zoneList.map(z => {
              const p1 = pitchGrid[z.pitches[0]] || [0, 0];
              const p2 = pitchGrid[z.pitches[1]] || [0, 0];
              return { id: z.id, row: (p1[0] + p2[0]) / 2, col: (p1[1] + p2[1]) / 2 };
            });
            const adjacencyMap = {};
            zoneCenters.forEach(zc => {
              adjacencyMap[zc.id] = zoneCenters
                .filter(other => other.id !== zc.id)
                .sort((a, b) => {
                  const distA = Math.abs(a.row - zc.row) + Math.abs(a.col - zc.col);
                  const distB = Math.abs(b.row - zc.row) + Math.abs(b.col - zc.col);
                  return distA - distB;
                })
                .map(other => other.id);
            });
            return adjacencyMap;
          };

          const assignTeamsToZones = (teamList, zoneList) => {
            const numZones = zoneList.length;
            const maxPerZone = Math.ceil(teamList.length / numZones);
            const clubGroups = {};
            teamList.forEach(t => {
              if (!clubGroups[t.club]) clubGroups[t.club] = [];
              clubGroups[t.club].push(t);
            });
            const sortedClubs = Object.keys(clubGroups).sort(
              (a, b) => clubGroups[b].length - clubGroups[a].length
            );
            zoneList.forEach(z => { z.teams = []; });
            let globalOffset = 0;
            sortedClubs.forEach(club => {
              const clubTeams = clubGroups[club];
              let zoneIdx = globalOffset;
              clubTeams.forEach(team => {
                let placed = false;
                for (let attempt = 0; attempt < numZones; attempt++) {
                  const candidateIdx = (zoneIdx + attempt) % numZones;
                  if (zoneList[candidateIdx].teams.length < maxPerZone) {
                    zoneList[candidateIdx].teams.push(team);
                    team.zone = zoneList[candidateIdx].id;
                    zoneIdx = (candidateIdx + 1) % numZones;
                    placed = true;
                    break;
                  }
                }
                if (!placed) {
                  const leastFull = zoneList.reduce((a, b) => a.teams.length <= b.teams.length ? a : b);
                  leastFull.teams.push(team);
                  team.zone = leastFull.id;
                }
              });
              globalOffset = (globalOffset + 1) % numZones;
            });
            return zoneList;
          };

          const findBestMatch = (candidates, playedMatchups, clubMatchupsPerTeam, teamFixtureCounts, targetRounds, adjacency) => {
            let bestMatch = null;
            let bestScore = -Infinity;
            for (let i = 0; i < candidates.length; i++) {
              const t1 = candidates[i];
              for (let j = i + 1; j < candidates.length; j++) {
                const t2 = candidates[j];
                const matchupKey = [t1.id, t2.id].sort().join('-');
                if (t1.club === t2.club) continue;
                if (playedMatchups.has(matchupKey)) continue;
                const t1PlayedClub = clubMatchupsPerTeam[t1.id].has(t2.club);
                const t2PlayedClub = clubMatchupsPerTeam[t2.id].has(t1.club);
                let score = 1000;
                if (!t1PlayedClub && !t2PlayedClub) score += 100;
                else if (!t1PlayedClub || !t2PlayedClub) score += 50;
                else score -= 100;
                score += (targetRounds - teamFixtureCounts[t1.id]) * 20;
                score += (targetRounds - teamFixtureCounts[t2.id]) * 20;
                score += (10 - clubMatchupsPerTeam[t1.id].size) * 5;
                score += (10 - clubMatchupsPerTeam[t2.id].size) * 5;
                if (t1.zone && t2.zone) {
                  if (t1.zone === t2.zone) {
                    score += 200;
                  } else if (adjacency && adjacency[t1.zone] && adjacency[t1.zone].indexOf(t2.zone) < 2) {
                    score += 50;
                  }
                }
                if (score > bestScore) {
                  bestScore = score;
                  bestMatch = { t1, t2, matchupKey };
                }
              }
            }
            return bestMatch;
          };

          const generateFixtures = async () => {
            setLoading(true);
            setError('');

            try {
              const teamList = teams.length > 0 ? [...teams] : generateSampleTeams();

              // Phase 0: Zone setup
              const minTeamsPerZone = 3;
              const maxZonesByPitches = Math.floor(numPitches / 2);
              const maxZonesByTeams = Math.floor(teamList.length / minTeamsPerZone);
              const activeZoneCount = Math.min(maxZonesByPitches, maxZonesByTeams);
              const activePitchCount = activeZoneCount * 2;

              const zoneList = computeZones(activePitchCount);
              const pitchGrid = computePitchGrid(activePitchCount);
              const adjacency = computeZoneAdjacency(zoneList, pitchGrid);
              assignTeamsToZones(teamList, zoneList);

              // Tracking structures
              const allFixtures = [];
              const teamFixtureCounts = {};
              const playedMatchups = new Set();
              const clubMatchupsPerTeam = {};

              teamList.forEach(t => {
                teamFixtureCounts[t.id] = 0;
                clubMatchupsPerTeam[t.id] = new Set();
              });

              let totalRounds = 0;
              const maxRounds = numRounds * 3;
              let currentTime = startTime;

              const recordMatch = (t1, t2, matchupKey, usedSet) => {
                playedMatchups.add(matchupKey);
                teamFixtureCounts[t1.id]++;
                teamFixtureCounts[t2.id]++;
                usedSet.add(t1.id);
                usedSet.add(t2.id);
                clubMatchupsPerTeam[t1.id].add(t2.club);
                clubMatchupsPerTeam[t2.id].add(t1.club);
              };

              // Phase 1 & 2: Round-by-round generation
              while (totalRounds < maxRounds) {
                const teamsNeedingMatches = teamList.filter(t => teamFixtureCounts[t.id] < numRounds);
                if (teamsNeedingMatches.length === 0) break;

                const usedTeamsThisRound = new Set();
                const roundFixtures = [];
                const filledPitches = new Set();

                // Phase 1: Intra-zone matches
                for (const zone of zoneList) {
                  for (let pitchSlot = 0; pitchSlot < 2; pitchSlot++) {
                    const pitch = zone.pitches[pitchSlot];
                    const availableInZone = zone.teams.filter(
                      t => !usedTeamsThisRound.has(t.id) && teamFixtureCounts[t.id] < numRounds
                    );
                    if (availableInZone.length < 2) break;

                    const match = findBestMatch(availableInZone, playedMatchups, clubMatchupsPerTeam, teamFixtureCounts, numRounds, adjacency);
                    if (!match) break;

                    const { t1, t2, matchupKey } = match;
                    roundFixtures.push({
                      id: `fixture-${totalRounds}-${pitch}`,
                      round: totalRounds + 1,
                      pitch,
                      time: currentTime,
                      team1: t1,
                      team2: t2,
                      zone: zone.id,
                      isCrossZone: false,
                    });
                    recordMatch(t1, t2, matchupKey, usedTeamsThisRound);
                    filledPitches.add(pitch);
                  }
                }

                // Phase 2: Cross-zone backfill for unfilled pitch slots
                for (const zone of zoneList) {
                  for (const pitch of zone.pitches) {
                    if (filledPitches.has(pitch)) continue;

                    // Gather candidates from all zones, ordered by proximity to this zone
                    const zoneOrder = [zone.id, ...(adjacency[zone.id] || [])];
                    const candidates = [];
                    for (const zId of zoneOrder) {
                      const z = zoneList.find(zz => zz.id === zId);
                      if (!z) continue;
                      z.teams.forEach(t => {
                        if (!usedTeamsThisRound.has(t.id) && teamFixtureCounts[t.id] < numRounds) {
                          candidates.push(t);
                        }
                      });
                    }
                    if (candidates.length < 2) continue;

                    const match = findBestMatch(candidates, playedMatchups, clubMatchupsPerTeam, teamFixtureCounts, numRounds, adjacency);
                    if (!match) continue;

                    const { t1, t2, matchupKey } = match;
                    roundFixtures.push({
                      id: `fixture-${totalRounds}-${pitch}`,
                      round: totalRounds + 1,
                      pitch,
                      time: currentTime,
                      team1: t1,
                      team2: t2,
                      zone: zone.id,
                      isCrossZone: t1.zone !== t2.zone,
                    });
                    recordMatch(t1, t2, matchupKey, usedTeamsThisRound);
                    filledPitches.add(pitch);
                  }
                }

                if (roundFixtures.length > 0) {
                  allFixtures.push(...roundFixtures);
                } else {
                  break;
                }

                totalRounds++;
                let nextTime = addMinutes(currentTime, matchDuration);
                currentTime = getNextAvailableTime(nextTime);
              }

              if (allFixtures.length === 0) {
                setError('Failed to generate fixtures. Try adjusting the number of pitches or rounds.');
              } else {
                setFixtures(allFixtures);
                setTeams(teamList);
                setZones(zoneList);
                await saveFixtures(allFixtures, teamList, zoneList);

                const fixtureCounts = Object.values(teamFixtureCounts);
                const minFixtures = Math.min(...fixtureCounts);
                const maxFixtures = Math.max(...fixtureCounts);
                const avgFixtures = (fixtureCounts.reduce((a, b) => a + b, 0) / fixtureCounts.length).toFixed(1);
                const teamsWithTarget = fixtureCounts.filter(c => c === numRounds).length;

                const intraZoneCount = allFixtures.filter(f => !f.isCrossZone).length;
                const crossZoneCount = allFixtures.filter(f => f.isCrossZone).length;
                const intraPercent = allFixtures.length > 0 ? Math.round(intraZoneCount / allFixtures.length * 100) : 0;

                let summary = `Generated ${allFixtures.length} fixtures across ${totalRounds} rounds in ${zoneList.length} zones. `;
                summary += `Teams have ${minFixtures}-${maxFixtures} matches (avg: ${avgFixtures}). `;
                summary += `${teamsWithTarget}/${teamList.length} teams have exactly ${numRounds} matches. `;
                summary += `${intraPercent}% intra-zone, ${100 - intraPercent}% cross-zone.`;

                setError(summary);
                console.log(summary);
              }
            } catch (err) {
              setError('Error generating fixtures: ' + err.message);
              console.error(err);
            }

            setLoading(false);
          };

          const filteredTeams = teams.filter(t => 
            t.name.toLowerCase().includes(searchTerm.toLowerCase())
          );

          const getTeamFixtures = (teamId) => {
            return fixtures.filter(f => 
              f.team1.id === teamId || f.team2.id === teamId
            ).sort((a, b) => a.time.localeCompare(b.time));
          };

          const getCurrentAndNext = () => {
            const now = new Date();
            const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;

            const current = fixtures.filter(f => f.time <= currentTime &&
              currentTime < addMinutes(f.time, matchDuration));
            const upcoming = fixtures.filter(f => f.time > currentTime)
              .sort((a, b) => a.time.localeCompare(b.time))
              .slice(0, numPitches);

            // If no current or upcoming matches, we're outside schedule times
            // Show all fixtures so the page isn't blank
            if (current.length === 0 && upcoming.length === 0 && fixtures.length > 0) {
              const allSorted = [...fixtures].sort((a, b) => a.time.localeCompare(b.time));
              return { current: [], upcoming: [], allFixtures: allSorted, outsideSchedule: true };
            }

            return { current, upcoming, allFixtures: [], outsideSchedule: false };
          };
           const downloadFixturesAsExcel = async () => {
            try {
              if (!window.XLSX) {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                await new Promise((resolve, reject) => {
                  script.onload = resolve;
                  script.onerror = reject;
                  document.head.appendChild(script);
                });
              }

              const wb = window.XLSX.utils.book_new();

              const fixtureData = [['Round', 'Time', 'Pitch', 'Zone', 'Team 1', 'Team 2', 'Club 1', 'Club 2', 'Cross-Zone']];
              fixtures.forEach(f => {
                fixtureData.push([f.round, f.time, f.pitch, f.zone || '', f.team1.name, f.team2.name, f.team1.club, f.team2.club, f.isCrossZone ? 'Yes' : '']);
              });
              const wsFixtures = window.XLSX.utils.aoa_to_sheet(fixtureData);
              window.XLSX.utils.book_append_sheet(wb, wsFixtures, 'All Fixtures');

              const teamData = [['Team', 'Club', 'Home Zone', 'Round', 'Time', 'Pitch', 'Zone', 'Opponent', 'Opponent Club']];
              teams.forEach(team => {
                const teamFixtures = fixtures.filter(f => f.team1.id === team.id || f.team2.id === team.id)
                  .sort((a, b) => a.time.localeCompare(b.time));
                teamFixtures.forEach(f => {
                  const opponent = f.team1.id === team.id ? f.team2 : f.team1;
                  teamData.push([team.name, team.club, team.zone || '', f.round, f.time, f.pitch, f.zone || '', opponent.name, opponent.club]);
                });
              });
              const wsTeams = window.XLSX.utils.aoa_to_sheet(teamData);
              window.XLSX.utils.book_append_sheet(wb, wsTeams, 'By Team');

              const rounds = [...new Set(fixtures.map(f => f.round))].sort((a, b) => a - b);
              const roundData = [['Round', 'Time', 'Pitch', 'Zone', 'Team 1', 'Team 2']];
              rounds.forEach(round => {
                const roundFixtures = fixtures.filter(f => f.round === round).sort((a, b) => a.pitch - b.pitch);
                roundFixtures.forEach(f => {
                  roundData.push([f.round, f.time, f.pitch, f.zone || '', f.team1.name, f.team2.name]);
                });
                if (round < rounds.length) {
                  roundData.push(['', '', '', '', '', '']);
                }
              });
              const wsRounds = window.XLSX.utils.aoa_to_sheet(roundData);
              window.XLSX.utils.book_append_sheet(wb, wsRounds, 'By Round');

              const pitches = [...new Set(fixtures.map(f => f.pitch))].sort((a, b) => a - b);
              const pitchData = [['Pitch', 'Zone', 'Time', 'Round', 'Team 1', 'Team 2']];
              pitches.forEach(pitch => {
                const pitchFixtures = fixtures.filter(f => f.pitch === pitch).sort((a, b) => a.time.localeCompare(b.time));
                const pitchZone = zones.find(z => z.pitches.includes(pitch));
                pitchFixtures.forEach(f => {
                  pitchData.push([f.pitch, pitchZone ? pitchZone.id : '', f.time, f.round, f.team1.name, f.team2.name]);
                });
                if (pitch < pitches.length) {
                  pitchData.push(['', '', '', '', '', '']);
                }
              });
              const wsPitches = window.XLSX.utils.aoa_to_sheet(pitchData);
              window.XLSX.utils.book_append_sheet(wb, wsPitches, 'By Pitch');

              const allTimes = [...new Set(fixtures.map(f => f.time))].sort();
              const matrixData = [['Team', 'Zone', ...allTimes]];
              teams.forEach(team => {
                const row = [team.name, team.zone || ''];
                allTimes.forEach(time => {
                  const fixture = fixtures.find(f => f.time === time && (f.team1.id === team.id || f.team2.id === team.id));
                  if (fixture) {
                    const opponent = fixture.team1.id === team.id ? fixture.team2 : fixture.team1;
                    row.push(opponent.name);
                  } else {
                    row.push('');
                  }
                });
                matrixData.push(row);
              });
              const wsMatrix = window.XLSX.utils.aoa_to_sheet(matrixData);
              window.XLSX.utils.book_append_sheet(wb, wsMatrix, 'Team Schedule Matrix');

              if (zones.length > 0) {
                const zoneSheetData = [['Zone', 'Pitches', 'Teams', 'Team Names', 'Clubs Represented', 'Intra-Zone Matches', 'Cross-Zone Matches']];
                zones.forEach(zone => {
                  const zoneFixtures = fixtures.filter(f => f.zone === zone.id);
                  const intraCount = zoneFixtures.filter(f => !f.isCrossZone).length;
                  const crossCount = zoneFixtures.filter(f => f.isCrossZone).length;
                  const clubs = [...new Set(zone.teams.map(t => t.club))];
                  zoneSheetData.push([
                    zone.id,
                    zone.pitches.join(', '),
                    zone.teams.length,
                    zone.teams.map(t => t.name).join(', '),
                    clubs.join(', '),
                    intraCount,
                    crossCount,
                  ]);
                });
                const wsZones = window.XLSX.utils.aoa_to_sheet(zoneSheetData);
                window.XLSX.utils.book_append_sheet(wb, wsZones, 'Zone Summary');
              }

              window.XLSX.writeFile(wb, 'Rugby_Festival_Fixtures.xlsx');
            } catch (err) {
              setError('Error generating Excel file: ' + err.message);
              console.error(err);
            }
          };

          if (view === 'admin') {
            if (!isAuthenticated) {
              return (
                <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
                  <div className="bg-white rounded-lg shadow-lg p-8 max-w-md w-full">
                    <h1 className="text-2xl font-bold text-gray-900 mb-4">Admin Access</h1>
                    <p className="text-gray-600 mb-6">Please enter the password to access the admin panel.</p>
                    <input
                      type="password"
                      value={passwordInput}
                      onChange={(e) => setPasswordInput(e.target.value)}
                      onKeyPress={(e) => {
                        if (e.key === 'Enter') {
                          if (passwordInput === 'Nissan01') {
                            setIsAuthenticated(true);
                          } else {
                            alert('Incorrect password');
                            setPasswordInput('');
                          }
                        }
                      }}
                      placeholder="Enter password"
                      className="w-full px-4 py-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      autoFocus
                    />
                    <button
                      onClick={() => {
                        if (passwordInput === 'Nissan01') {
                          setIsAuthenticated(true);
                        } else {
                          alert('Incorrect password');
                          setPasswordInput('');
                        }
                      }}
                      className="w-full px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                    >
                      Login
                    </button>
                  </div>
                </div>
              );
            }

            return (
              <div className="min-h-screen bg-gray-50 p-4">
                <div className="max-w-6xl mx-auto">
                  <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <div className="flex items-center justify-between mb-6">
                      <div>
                        <h1 className="text-3xl font-bold text-gray-900">U7's Waterfall</h1>
                        <p className="text-gray-600 mt-1">Generate and manage fixtures</p>
                      </div>
                                    </div>
                    {error && (
                      <div className={`mb-4 p-4 ${error.includes('Successfully') ? 'bg-[#7c1229]/5 border-green-200 text-green-700' : 'bg-red-50 border-red-200 text-red-700'} border rounded-lg`}>
                        {error}
                      </div>
                    )}
                    <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                      <h3 className="font-semibold text-blue-900 mb-3">Load Teams from Google Sheet</h3>
                      <div className="mb-3 flex gap-2">
                        <button onClick={() => setUploadMethod('url')} className={`px-4 py-2 rounded-lg ${uploadMethod === 'url' ? 'bg-blue-600 text-white' : 'bg-white text-blue-600 border border-blue-300'}`}>From URL</button>
                        <button onClick={() => setUploadMethod('file')} className={`px-4 py-2 rounded-lg ${uploadMethod === 'file' ? 'bg-blue-600 text-white' : 'bg-white text-blue-600 border border-blue-300'}`}>Upload File</button>
                      </div>
                      {uploadMethod === 'url' ? (
                        <div className="space-y-3">
                          <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">Google Sheet URL</label>
                            <div className="flex gap-2">
                              <input type="text" value={sheetUrl} onChange={(e) => setSheetUrl(e.target.value)} placeholder="https://docs.google.com/spreadsheets/d/..." className="flex-1 px-3 py-2 border border-gray-300 rounded-lg" />
                              {sheetUrl && (
                                <button onClick={() => setSheetUrl('')} className="px-3 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 text-sm font-medium whitespace-nowrap">
                                  Clear
                                </button>
                              )}
                            </div>
                            <p className="text-xs text-gray-600 mt-1">Make sure your sheet is published to web</p>
                          </div>
                          <button onClick={loadTeamsFromSheet} disabled={loadingSheet || !sheetUrl} className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400">
                            <Download size={18} className={loadingSheet ? 'animate-spin' : ''} />
                            {loadingSheet ? 'Loading...' : 'Load Teams from Sheet'}
                          </button>
                        </div>
                      ) : (
                        <div className="space-y-3">
                          <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">Upload Excel or CSV File</label>
                            <p className="text-xs text-gray-600 mb-2">Download your sheet as Excel (.xlsx) or CSV</p>
                            <input type="file" accept=".csv,.xlsx,.xls" onChange={handleFileUpload} className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white" />
                          </div>
                        </div>
                      )}
                      {teams.length > 0 && <p className="text-sm text-green-700 font-medium mt-3">âœ“ {teams.length} teams loaded and ready</p>}
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Number of Rounds</label>
                        <input type="number" value={numRounds} onChange={(e) => setNumRounds(parseInt(e.target.value))} className="w-full px-3 py-2 border border-gray-300 rounded-lg" min="4" max="12" />
                        <p className="text-xs text-gray-600 mt-1">Matches per team</p>
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Number of Pitches</label>
                        <input type="number" value={numPitches} onChange={(e) => setNumPitches(parseInt(e.target.value))} className="w-full px-3 py-2 border border-gray-300 rounded-lg" min="4" max="20" />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Match Duration (mins)</label>
                        <input type="number" value={matchDuration} onChange={(e) => setMatchDuration(parseInt(e.target.value))} className="w-full px-3 py-2 border border-gray-300 rounded-lg" min="10" max="20" />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Start Time</label>
                        <input type="time" value={startTime} onChange={(e) => setStartTime(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                      </div>
                    </div>
                    <div className="mb-6 p-4 bg-amber-50 border border-amber-200 rounded-lg">
                      <div className="flex items-center gap-2 mb-3">
                        <input type="checkbox" id="lunchEnabled" checked={lunchEnabled} onChange={(e) => setLunchEnabled(e.target.checked)} className="w-4 h-4" />
                        <label htmlFor="lunchEnabled" className="font-semibold text-amber-900">Schedule Lunch Break</label>
                      </div>
                      {lunchEnabled && (
                        <div className="grid grid-cols-2 gap-4">
                          <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">Lunch Start</label>
                            <input type="time" value={lunchStart} onChange={(e) => setLunchStart(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                          </div>
                          <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">Lunch End</label>
                            <input type="time" value={lunchEnd} onChange={(e) => setLunchEnd(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                          </div>
                        </div>
                      )}
                    </div>
                    <button onClick={generateFixtures} disabled={loading} className="w-full flex items-center justify-center gap-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400">
                      <RefreshCw size={20} className={loading ? 'animate-spin' : ''} />
                      {loading ? 'Generating...' : 'Generate Fixtures'}
                    </button>
                  </div>
                  {zones.length > 0 && (
                    <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                      <h2 className="text-2xl font-bold text-gray-900 mb-4">Pitch Layout & Zones</h2>
                      {(() => {
                        const zoneColors = {
                          A: 'bg-red-100 border-red-400 text-red-800',
                          B: 'bg-blue-100 border-blue-400 text-blue-800',
                          C: 'bg-green-100 border-green-400 text-green-800',
                          D: 'bg-yellow-100 border-yellow-400 text-yellow-800',
                          E: 'bg-purple-100 border-purple-400 text-purple-800',
                          F: 'bg-pink-100 border-pink-400 text-pink-800',
                          G: 'bg-indigo-100 border-indigo-400 text-indigo-800',
                          H: 'bg-orange-100 border-orange-400 text-orange-800',
                        };
                        const activePitchCount = zones.length * 2;
                        const grid = computePitchGrid(activePitchCount);
                        const numCols = Math.min(4, Math.ceil(activePitchCount / 4) > 0 ? 4 : 2);
                        const numRows = Math.ceil(activePitchCount / numCols);
                        const pitchToZone = {};
                        zones.forEach(z => { z.pitches.forEach(p => { pitchToZone[p] = z.id; }); });
                        const gridCells = [];
                        for (let r = 0; r < numRows; r++) {
                          for (let c = 0; c < numCols; c++) {
                            const entry = Object.entries(grid).find(([_, pos]) => pos[0] === r && pos[1] === c);
                            gridCells.push(entry ? { pitch: parseInt(entry[0]), row: r, col: c } : null);
                          }
                        }
                        return (
                          <div>
                            <div className="inline-grid gap-2 mb-6" style={{ gridTemplateColumns: `repeat(${numCols}, 1fr)` }}>
                              {gridCells.map((cell, idx) => {
                                if (!cell) return <div key={idx}></div>;
                                const zId = pitchToZone[cell.pitch];
                                const colorClass = zoneColors[zId] || 'bg-gray-100 border-gray-300 text-gray-700';
                                return (
                                  <div key={idx} className={`${colorClass} border-2 rounded-lg p-3 text-center min-w-[80px]`}>
                                    <div className="text-lg font-bold">P{cell.pitch}</div>
                                    <div className="text-xs font-medium">Zone {zId}</div>
                                  </div>
                                );
                              })}
                            </div>
                            <h3 className="text-lg font-bold text-gray-900 mb-3">Zone Assignments</h3>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                              {zones.map(zone => {
                                const colorClass = zoneColors[zone.id] || 'bg-gray-100 border-gray-300';
                                return (
                                  <div key={zone.id} className={`${colorClass} border-2 rounded-lg p-3`}>
                                    <h4 className="font-bold text-lg">Zone {zone.id}</h4>
                                    <p className="text-sm mb-2">Pitches {zone.pitches.join(' & ')}</p>
                                    <ul className="text-sm space-y-1">
                                      {zone.teams.map(t => (
                                        <li key={t.id}>{t.name} <span className="opacity-60">({t.club})</span></li>
                                      ))}
                                    </ul>
                                  </div>
                                );
                              })}
                            </div>
                          </div>
                        );
                      })()}
                    </div>
                  )}
                  {fixtures.length > 0 && (
                    <div className="bg-white rounded-lg shadow-lg p-6">
                      <div className="flex items-center justify-between mb-4">
                        <h2 className="text-2xl font-bold text-gray-900">Generated Fixtures ({fixtures.length} matches)</h2>
                        <div className="flex gap-2">
                          <div className="text-sm text-gray-600">{teams.length} teams</div>
                          <button onClick={downloadFixturesAsExcel} className="flex items-center gap-2 px-4 py-2 bg-[#7c1229] text-white rounded-lg hover:bg-[#a01638]">
                            <Download size={18} />
                            Download Excel
                          </button>
                        </div>
                      </div>
                      <div className="overflow-x-auto">
                        <table className="w-full">
                          <thead className="bg-gray-50">
                            <tr>
                              <th className="px-4 py-3 text-left text-sm font-medium text-gray-700">Time</th>
                              <th className="px-4 py-3 text-left text-sm font-medium text-gray-700">Pitch</th>
                              <th className="px-4 py-3 text-left text-sm font-medium text-gray-700">Zone</th>
                              <th className="px-4 py-3 text-left text-sm font-medium text-gray-700">Team 1</th>
                              <th className="px-4 py-3 text-left text-sm font-medium text-gray-700">Team 2</th>
                            </tr>
                          </thead>
                          <tbody className="divide-y divide-gray-200">
                            {fixtures.slice(0, 30).map(f => (
                              <tr key={f.id} className="hover:bg-gray-50">
                                <td className="px-4 py-3 text-sm">{f.time}</td>
                                <td className="px-4 py-3 text-sm font-medium">Pitch {f.pitch}</td>
                                <td className="px-4 py-3 text-sm">
                                  {f.zone && <span className={f.isCrossZone ? 'text-amber-600 font-medium' : 'font-medium'}>Zone {f.zone}{f.isCrossZone ? ' *' : ''}</span>}
                                </td>
                                <td className="px-4 py-3 text-sm">{f.team1.name}</td>
                                <td className="px-4 py-3 text-sm">{f.team2.name}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                        {fixtures.length > 30 && <p className="text-center text-gray-500 mt-4">Showing 30 of {fixtures.length} fixtures. * = cross-zone match</p>}
                      </div>
                    </div>
                  )}
                </div>
              </div>
            );
          }
           const { current, upcoming, allFixtures, outsideSchedule } = getCurrentAndNext();
          const teamFixtures = selectedTeam ? getTeamFixtures(selectedTeam.id) : [];

          return (
            <div className="min-h-screen bg-gradient-to-b from-green-50 to-white">
              <div className="bg-[#7c1229] text-white p-4 sticky top-0 z-10 shadow-lg">
                <div className="max-w-2xl mx-auto">
                  <div className="flex items-center justify-between mb-3">
                    <h1 className="text-2xl font-bold">U7's Waterfall</h1>
                                      </div>
                  <div className="relative">
                    <Search className="absolute left-3 top-3 text-[#7c1229]" size={20} />
                    <input type="text" placeholder="Search for your team..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="w-full pl-10 pr-4 py-3 rounded-lg text-gray-900 text-lg" />
                  </div>
                  {searchTerm && (
                    <div className="mt-2 bg-white rounded-lg shadow-lg max-h-60 overflow-y-auto">
                      {filteredTeams.map(team => (
                        <button key={team.id} onClick={() => { setSelectedTeam(team); setSearchTerm(''); }} className="w-full px-4 py-3 text-left hover:bg-[#7c1229]/5 border-b border-gray-100 text-gray-900">
                          <div className="font-medium">{team.name}</div>
                          <div className="text-sm text-gray-600">Club: {team.club}</div>
                          {team.zone && <div className="text-sm text-[#7c1229] font-medium">Zone {team.zone}</div>}
                        </button>
                      ))}
                    </div>
                  )}
                </div>
              </div>
              <div className="max-w-2xl mx-auto p-4">
                {fixtures.length === 0 ? (
                  <div className="bg-white rounded-lg shadow-lg p-8 text-center">
                    <Calendar size={48} className="mx-auto text-gray-400 mb-4" />
                    <h2 className="text-xl font-bold text-gray-900 mb-2">No Fixtures Yet</h2>
                    <p className="text-gray-600">Fixtures will appear here once generated by the admin.</p>
                  </div>
                ) : selectedTeam ? (
                  <div>
                    <button onClick={() => setSelectedTeam(null)} className="mb-4 text-[#7c1229] font-medium">â† Back to all fixtures</button>
                    <div className="bg-white rounded-lg shadow-lg p-4 mb-4">
                      <h2 className="text-xl font-bold text-gray-900">{selectedTeam.name}</h2>
                      <p className="text-gray-600">Club: {selectedTeam.club}</p>
                      {selectedTeam.zone && (
                        <>
                          <p className="text-[#7c1229] font-semibold text-lg">
                            Zone {selectedTeam.zone} (Pitches {zones.find(z => z.id === selectedTeam.zone)?.pitches.join(' & ')})
                          </p>
                          {(() => {
                            const teamZone = zones.find(z => z.id === selectedTeam.zone);
                            if (!teamZone) return null;
                            const groupMembers = teamZone.teams.filter(t => t.id !== selectedTeam.id);
                            if (groupMembers.length === 0) return null;
                            return (
                              <div className="mt-2 p-3 bg-gray-50 rounded-lg">
                                <p className="text-sm font-semibold text-gray-700 mb-1">Group {selectedTeam.zone} Teams:</p>
                                <div className="flex flex-wrap gap-1">
                                  {groupMembers.map(t => (
                                    <span key={t.id} className="px-2 py-0.5 bg-[#7c1229]/10 text-[#7c1229] rounded text-xs font-medium">
                                      {t.name}
                                    </span>
                                  ))}
                                </div>
                              </div>
                            );
                          })()}
                        </>
                      )}
                      <p className="text-gray-600 mt-2">{teamFixtures.length} fixtures</p>
                    </div>
                    <div className="space-y-3">
                      {teamFixtures.map((fixture, idx) => {
                        const opponent = fixture.team1.id === selectedTeam.id ? fixture.team2 : fixture.team1;
                        const isAway = selectedTeam.zone && fixture.zone !== selectedTeam.zone;
                        return (
                          <div key={fixture.id} className={`rounded-lg shadow p-4 ${isAway ? 'bg-amber-50 border-2 border-amber-400' : 'bg-white'}`}>
                            <div className="flex items-center justify-between mb-2">
                              <span className="text-2xl font-bold text-[#7c1229]">{fixture.time}</span>
                              <span className="text-lg font-medium text-gray-700">Match {idx + 1}</span>
                            </div>
                            <div className="flex items-center gap-2 mb-2">
                              <MapPin size={18} className={isAway ? 'text-amber-600' : 'text-gray-500'} />
                              <span className="font-medium text-gray-900">Pitch {fixture.pitch}</span>
                              {fixture.zone && (
                                isAway ? (
                                  <span className="px-2 py-0.5 bg-amber-500 text-white rounded text-xs font-bold">
                                    AWAY - Zone {fixture.zone}
                                  </span>
                                ) : (
                                  <span className="px-2 py-0.5 bg-[#7c1229]/10 text-[#7c1229] rounded text-xs font-medium">
                                    Zone {fixture.zone}
                                  </span>
                                )
                              )}
                            </div>
                            <div className="text-gray-700">
                              <span className="font-medium">vs</span> {opponent.name}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ) : (
                  <>
                    {outsideSchedule && (
                      <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg text-center">
                        <p className="text-blue-800 font-medium">No matches currently in progress - showing all fixtures</p>
                      </div>
                    )}
                    {current.length > 0 && (
                      <div className="mb-6">
                        <h2 className="text-xl font-bold text-gray-900 mb-3 flex items-center gap-2">
                          <div className="w-3 h-3 bg-red-500 rounded-full animate-pulse"></div>
                          Playing Now
                        </h2>
                        <div className="space-y-3">
                          {current.map(f => (
                            <div key={f.id} className="bg-white rounded-lg shadow-lg p-4 border-l-4 border-red-500">
                              <div className="flex items-center justify-between mb-2">
                                <span className="text-xl font-bold text-gray-900">{f.time}</span>
                                <span className="flex items-center gap-1 font-medium text-gray-700">
                                  <MapPin size={16} />
                                  Pitch {f.pitch}
                                  {f.zone && <span className="text-xs text-[#7c1229] ml-1">(Zone {f.zone})</span>}
                                </span>
                              </div>
                              <div className="text-gray-900">
                                <div className="font-medium">{f.team1.name}</div>
                                <div className="text-gray-500 text-sm my-1">vs</div>
                                <div className="font-medium">{f.team2.name}</div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                    {upcoming.length > 0 && (
                      <div>
                        <h2 className="text-xl font-bold text-gray-900 mb-3">Up Next</h2>
                        <div className="space-y-3">
                          {upcoming.map(f => (
                            <div key={f.id} className="bg-white rounded-lg shadow p-4">
                              <div className="flex items-center justify-between mb-2">
                                <span className="text-xl font-bold text-[#7c1229]">{f.time}</span>
                                <span className="flex items-center gap-1 font-medium text-gray-700">
                                  <MapPin size={16} />
                                  Pitch {f.pitch}
                                  {f.zone && <span className="text-xs text-[#7c1229] ml-1">(Zone {f.zone})</span>}
                                </span>
                              </div>
                              <div className="text-gray-900 text-sm">
                                <div>{f.team1.name}</div>
                                <div className="text-gray-500 my-1">vs</div>
                                <div>{f.team2.name}</div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                    {outsideSchedule && allFixtures.length > 0 && (
                      <div>
                        <h2 className="text-xl font-bold text-gray-900 mb-3">All Fixtures</h2>
                        <div className="space-y-3">
                          {allFixtures.map(f => (
                            <div key={f.id} className="bg-white rounded-lg shadow p-4">
                              <div className="flex items-center justify-between mb-2">
                                <span className="text-xl font-bold text-[#7c1229]">{f.time}</span>
                                <span className="flex items-center gap-1 font-medium text-gray-700">
                                  <MapPin size={16} />
                                  Pitch {f.pitch}
                                  {f.zone && <span className="text-xs text-[#7c1229] ml-1">(Zone {f.zone})</span>}
                                </span>
                              </div>
                              <div className="text-gray-900 text-sm">
                                <div>{f.team1.name}</div>
                                <div className="text-gray-500 my-1">vs</div>
                                <div>{f.team2.name}</div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </>
                )}
              </div>
            </div>
          );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<RugbyFixtureApp />);
    </script>
</body>
</html>


