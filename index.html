<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>U7's Waterfall - Rugby Fixtures</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.4/jspdf.plugin.autotable.min.js"></script>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @media print {
            body { margin: 0; padding: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            .no-print { display: none !important; }
            .print-only { display: block !important; }
            .print-page-break { page-break-after: always; }
            .print-table { width: 100%; border-collapse: collapse; font-size: 10pt; }
            .print-table th, .print-table td { border: 1px solid #333; padding: 4px 6px; text-align: left; }
            .print-table th { background: #333 !important; color: #fff !important; font-weight: bold; }
            .print-table tr:nth-child(even) { background: #f0f0f0 !important; }
            .print-header { text-align: center; margin-bottom: 10px; }
            .print-header h1 { font-size: 18pt; margin: 0; }
            .print-header p { font-size: 10pt; margin: 2px 0; color: #666; }
        }

        .print-only { display: none; }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;
        
        const Calendar = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="16" y1="2" x2="16" y2="6"></line>
                <line x1="8" y1="2" x2="8" y2="6"></line>
                <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>
        );
        
        const MapPin = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
            </svg>
        );
        
        const Search = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
            </svg>
        );
        
        const RefreshCw = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        );
        
        const Eye = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>
        );
        
        const Download = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        );

        const X = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );

        const ZoomIn = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        );

        const ZoomOut = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        );

        const JSONBIN_API_KEY = '$2a$10$/1IjctFCm8nvzrKEAH/KOO3MO6Jj090RnDWC3dxIFwfT2wBgC6.EO';
        const JSONBIN_BIN_ID = '698c5fe3ae596e708f2250a9';

        window.storage = {
            get: async function(key) {
                try {
                    const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}/latest`, {
                        method: 'GET',
                        headers: {
                            'X-Access-Key': JSONBIN_API_KEY
                        }
                    });
                    
                    if (!response.ok) {
                        console.error('Failed to load from JSONBin:', response.status);
                        return null;
                    }
                    
                    const result = await response.json();
                    console.log('Loaded from JSONBin:', result.record);
                    return { key, value: JSON.stringify(result.record) };
                } catch (err) {
                    console.error('Error loading fixtures:', err);
                    return null;
                }
            },
            set: async function(key, value) {
                try {
                    const data = JSON.parse(value);
                    console.log('Saving to JSONBin:', data);
                    
                    const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Access-Key': JSONBIN_API_KEY
                        },
                        body: JSON.stringify(data)
                    });
                    
                    if (!response.ok) {
                        console.error('Failed to save to JSONBin:', response.status);
                        return null;
                    }
                    
                    const result = await response.json();
                    console.log('Saved to JSONBin successfully:', result);
                    return { key, value };
                } catch (err) {
                    console.error('Error saving fixtures:', err);
                    return null;
                }
            },
            delete: async function(key) {
                return { key, deleted: true };
            }
        };

        const RugbyFixtureApp = () => {
          const urlParams = new URLSearchParams(window.location.search);
          const initialView = urlParams.get('view') === 'public' ? 'public' : 'admin';
          
          const [view, setView] = useState(initialView);
          const [teams, setTeams] = useState([]);
          const [fixtures, setFixtures] = useState([]);
          const [zones, setZones] = useState([]);
          const [searchTerm, setSearchTerm] = useState('');
          const [selectedTeam, setSelectedTeam] = useState(null);
          const [showSitePlan, setShowSitePlan] = useState(false);
          const [sitePlanZoom, setSitePlanZoom] = useState(1);
          const [numPitches, setNumPitches] = useState(16);
          const [matchDuration, setMatchDuration] = useState(15);
          const [startTime, setStartTime] = useState('10:30');
          const [numRounds, setNumRounds] = useState(7);
          const [loading, setLoading] = useState(false);
          const [error, setError] = useState('');
          const [sheetUrl, setSheetUrl] = useState('https://docs.google.com/spreadsheets/d/13iFBeez2r61o2ZnvWrQhHz0lXLMkIa5qwj92hSkjUX0/edit?usp=sharing');
          const [loadingSheet, setLoadingSheet] = useState(false);
          const [uploadMethod, setUploadMethod] = useState('url');
          const [lunchEnabled, setLunchEnabled] = useState(true);
          const [lunchStart, setLunchStart] = useState('11:45');
          const [lunchEnd, setLunchEnd] = useState('12:30');
          const [isAuthenticated, setIsAuthenticated] = useState(false);
          const [passwordInput, setPasswordInput] = useState('');
          const [refreshTick, setRefreshTick] = useState(0);
          const [fixtureHistory, setFixtureHistory] = useState([]);
          const [swapMode, setSwapMode] = useState(null);
          const [pdfLoading, setPdfLoading] = useState(false);
          const [notificationsEnabled, setNotificationsEnabled] = useState(false);
          const [notifiedFixtures, setNotifiedFixtures] = useState(new Set());

          useEffect(() => {
            loadFixtures();
          }, []);

          // Auto-refresh public view every 60 seconds
          useEffect(() => {
            if (view !== 'public') return;
            const interval = setInterval(() => {
              setRefreshTick(t => t + 1);
              loadFixtures();
            }, 60000);
            return () => clearInterval(interval);
          }, [view]);

          useEffect(() => {
            if (showSitePlan) {
              document.body.style.overflow = 'hidden';
              document.documentElement.style.touchAction = 'none';
              const handleKeyDown = (e) => {
                if (e.key === 'Escape') setShowSitePlan(false);
              };
              window.addEventListener('keydown', handleKeyDown);
              return () => {
                document.body.style.overflow = '';
                document.documentElement.style.touchAction = '';
                window.removeEventListener('keydown', handleKeyDown);
                setSitePlanZoom(1);
              };
            } else {
              document.body.style.overflow = '';
              document.documentElement.style.touchAction = '';
            }
          }, [showSitePlan]);

          useEffect(() => {
            if (selectedTeam) {
              window.scrollTo(0, 0);
            }
          }, [selectedTeam]);

          const loadFixtures = async () => {
            try {
              const result = await window.storage.get('rugby-fixtures');
              if (result && result.value) {
                const data = JSON.parse(result.value);
                if (data.fixtures && data.fixtures.length > 0) {
                  setFixtures(data.fixtures || []);
                  
                  const teamMap = new Map();
                  data.fixtures.forEach(f => {
                    if (!teamMap.has(f.team1.id)) {
                      teamMap.set(f.team1.id, f.team1);
                    }
                    if (!teamMap.has(f.team2.id)) {
                      teamMap.set(f.team2.id, f.team2);
                    }
                  });
                  setTeams(Array.from(teamMap.values()));

                  if (data.zones && data.zones.length > 0) {
                    const restoredZones = data.zones.map(z => ({
                      id: z.id,
                      pitches: z.pitches,
                      teams: z.teamIds.map(id => teamMap.get(id)).filter(Boolean),
                    }));
                    setZones(restoredZones);
                  }
                }
              }
            } catch (error) {
              console.log('No existing fixtures found');
            }
          };

          const saveFixtures = async (fixtureData, teamData, zoneData, skipHistory = false) => {
            try {
              // Save current state to history before overwriting (max 10 entries)
              if (!skipHistory && fixtures.length > 0) {
                setFixtureHistory(prev => {
                  const entry = {
                    fixtures: [...fixtures],
                    teams: [...teams],
                    zones: [...zones],
                    timestamp: new Date().toISOString(),
                  };
                  const next = [entry, ...prev].slice(0, 10);
                  return next;
                });
              }

              console.log('Attempting to save fixtures...', fixtureData.length);
              const payload = {
                fixtures: fixtureData,
                teams: teamData,
                zones: zoneData ? zoneData.map(z => ({ id: z.id, pitches: z.pitches, teamIds: z.teams.map(t => t.id) })) : [],
                generated: new Date().toISOString()
              };
              console.log('Payload:', payload);

              const result = await window.storage.set('rugby-fixtures', JSON.stringify(payload));
              console.log('Save result:', result);

              if (!result) {
                console.error('Failed to save - no result returned');
              } else {
                console.log('Successfully saved fixtures');
              }
            } catch (error) {
              console.error('Error saving fixtures:', error);
            }
          };

          const restoreFromHistory = async (index) => {
            const entry = fixtureHistory[index];
            if (!entry) return;
            setFixtures(entry.fixtures);
            setTeams(entry.teams);
            setZones(entry.zones);
            await saveFixtures(entry.fixtures, entry.teams, entry.zones, true);
            setFixtureHistory(prev => prev.filter((_, i) => i !== index));
            setError(`Restored fixtures from ${new Date(entry.timestamp).toLocaleTimeString()}`);
          };

          const swapTeamsInFixture = async (fixtureId, newTeamId) => {
            if (!swapMode) return;
            const { fixtureId: srcFixtureId, slot: srcSlot } = swapMode;

            const srcFixture = fixtures.find(f => f.id === srcFixtureId);
            const destFixture = fixtures.find(f => f.id === fixtureId);
            if (!srcFixture || !destFixture) return;

            const srcTeam = srcSlot === 1 ? srcFixture.team1 : srcFixture.team2;
            const destTeam = destFixture.team1.id === newTeamId ? destFixture.team1 : destFixture.team2;
            const destSlot = destFixture.team1.id === newTeamId ? 1 : 2;

            const updated = fixtures.map(f => {
              if (f.id === srcFixtureId) {
                return { ...f, [srcSlot === 1 ? 'team1' : 'team2']: destTeam };
              }
              if (f.id === fixtureId) {
                return { ...f, [destSlot === 1 ? 'team1' : 'team2']: srcTeam };
              }
              return f;
            });

            setFixtures(updated);
            await saveFixtures(updated, teams, zones);
            setSwapMode(null);
            setError(`Swapped ${srcTeam.name} with ${destTeam.name}`);
          };

          const regenerateRound = async (roundNum) => {
            setLoading(true);
            try {
              const roundFixtures = fixtures.filter(f => f.round === roundNum);
              const otherFixtures = fixtures.filter(f => f.round !== roundNum);

              // Build tracking from other rounds only
              const playedMatchups = new Set();
              const clubMatchupsPerTeam = {};
              const teamFixtureCounts = {};
              teams.forEach(t => {
                teamFixtureCounts[t.id] = 0;
                clubMatchupsPerTeam[t.id] = new Set();
              });
              otherFixtures.forEach(f => {
                const key = [f.team1.id, f.team2.id].sort().join('-');
                playedMatchups.add(key);
                teamFixtureCounts[f.team1.id] = (teamFixtureCounts[f.team1.id] || 0) + 1;
                teamFixtureCounts[f.team2.id] = (teamFixtureCounts[f.team2.id] || 0) + 1;
                clubMatchupsPerTeam[f.team1.id].add(f.team2.club);
                clubMatchupsPerTeam[f.team2.id].add(f.team1.club);
              });

              const activePitchCount = zones.length * 2;
              const pitchGrid = computePitchGrid(activePitchCount);
              const adjacency = computeZoneAdjacency(zones, pitchGrid);

              const roundTime = roundFixtures[0]?.time || startTime;
              const usedTeams = new Set();
              const newRoundFixtures = [];
              const filledPitches = new Set();

              // Intra-zone
              for (const zone of zones) {
                for (let pitchSlot = 0; pitchSlot < 2; pitchSlot++) {
                  const pitch = zone.pitches[pitchSlot];
                  const available = zone.teams.filter(t => !usedTeams.has(t.id) && teamFixtureCounts[t.id] < numRounds);
                  if (available.length < 2) break;
                  const match = findBestMatch(available, playedMatchups, clubMatchupsPerTeam, teamFixtureCounts, numRounds, adjacency);
                  if (!match) break;
                  newRoundFixtures.push({
                    id: `fixture-${roundNum - 1}-${pitch}`,
                    round: roundNum, pitch, time: roundTime,
                    team1: match.t1, team2: match.t2,
                    zone: zone.id, isCrossZone: false,
                  });
                  playedMatchups.add(match.matchupKey);
                  usedTeams.add(match.t1.id);
                  usedTeams.add(match.t2.id);
                  filledPitches.add(pitch);
                }
              }

              // Cross-zone backfill
              for (const zone of zones) {
                for (const pitch of zone.pitches) {
                  if (filledPitches.has(pitch)) continue;
                  const zoneOrder = [zone.id, ...(adjacency[zone.id] || [])];
                  const candidates = [];
                  for (const zId of zoneOrder) {
                    const z = zones.find(zz => zz.id === zId);
                    if (!z) continue;
                    z.teams.forEach(t => {
                      if (!usedTeams.has(t.id) && teamFixtureCounts[t.id] < numRounds) candidates.push(t);
                    });
                  }
                  if (candidates.length < 2) continue;
                  const match = findBestMatch(candidates, playedMatchups, clubMatchupsPerTeam, teamFixtureCounts, numRounds, adjacency);
                  if (!match) continue;
                  newRoundFixtures.push({
                    id: `fixture-${roundNum - 1}-${pitch}`,
                    round: roundNum, pitch, time: roundTime,
                    team1: match.t1, team2: match.t2,
                    zone: zone.id, isCrossZone: match.t1.zone !== match.t2.zone,
                  });
                  playedMatchups.add(match.matchupKey);
                  usedTeams.add(match.t1.id);
                  usedTeams.add(match.t2.id);
                  filledPitches.add(pitch);
                }
              }

              const allFixtures = [...otherFixtures, ...newRoundFixtures].sort((a, b) =>
                a.time.localeCompare(b.time) || a.pitch - b.pitch
              );
              // Re-assign referees across all rounds (since changes ripple)
              assignReferees(allFixtures, zones);
              setFixtures(allFixtures);
              await saveFixtures(allFixtures, teams, zones);
              const conflictCount = allFixtures.filter(f => f.refereeConflict).length;
              setError(`Re-generated round ${roundNum} with ${newRoundFixtures.length} fixtures. Referee conflicts: ${conflictCount}`);
            } catch (err) {
              setError('Error re-generating round: ' + err.message);
            }
            setLoading(false);
          };
            const loadTeamsFromCSV = (csvText) => {
            const lines = csvText.split('\n');
            const loadedTeams = [];
            
            for (let i = 1; i < lines.length; i++) {
              const line = lines[i].trim();
              if (!line) continue;
              
              const columns = line.split(',').map(col => col.replace(/^"|"$/g, '').trim());
              
              const clubName = columns[0];
              const numTeams = parseInt(columns[1]) || 0;
              
              for (let t = 0; t < numTeams && t < 5; t++) {
                const teamName = columns[2 + t];
                if (teamName && teamName.trim() !== '') {
                  loadedTeams.push({
                    id: `team-${loadedTeams.length}`,
                    name: teamName.trim(),
                    club: clubName,
                    pitchAssignment: null
                  });
                }
              }
            }
            
            return loadedTeams;
          };

          const handleFileUpload = (event) => {
            setLoadingSheet(true);
            setError('');
            
            const file = event.target.files[0];
            if (!file) {
              setLoadingSheet(false);
              return;
            }
            
            const reader = new FileReader();
            reader.onload = async (e) => {
              try {
                const data = e.target.result;
                let loadedTeams = [];
                
                if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                  if (!window.XLSX) {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                    await new Promise((resolve, reject) => {
                      script.onload = resolve;
                      script.onerror = reject;
                      document.head.appendChild(script);
                    });
                  }
                  
                  const workbook = window.XLSX.read(data, { type: 'array' });
                  const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                  const csvText = window.XLSX.utils.sheet_to_csv(firstSheet);
                  
                  loadedTeams = loadTeamsFromCSV(csvText);
                } else {
                  const csvText = new TextDecoder().decode(data);
                  loadedTeams = loadTeamsFromCSV(csvText);
                }
                
                if (loadedTeams.length === 0) {
                  throw new Error('No teams found in file');
                }
                
                setTeams(loadedTeams);
                setError(`Successfully loaded ${loadedTeams.length} teams from ${new Set(loadedTeams.map(t => t.club)).size} clubs`);
              } catch (err) {
                setError('Error reading file: ' + err.message);
                console.error(err);
              }
              setLoadingSheet(false);
            };
            
            reader.onerror = () => {
              setError('Error reading file');
              setLoadingSheet(false);
            };
            
            if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
              reader.readAsArrayBuffer(file);
            } else {
              reader.readAsText(file);
            }
          };

          const loadTeamsFromSheet = async () => {
            setLoadingSheet(true);
            setError('');
            
            try {
              let sheetId = '';
              const urlMatch = sheetUrl.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
              if (urlMatch) {
                sheetId = urlMatch[1];
              } else {
                throw new Error('Invalid Google Sheets URL');
              }
              
              const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
              
              const response = await fetch(csvUrl, {
                method: 'GET',
                mode: 'cors'
              });
              
              if (!response.ok) {
                throw new Error('Failed to fetch sheet');
              }
              
              const csvText = await response.text();
              const loadedTeams = loadTeamsFromCSV(csvText);
              
              if (loadedTeams.length === 0) {
                throw new Error('No teams found in sheet');
              }
              
              setTeams(loadedTeams);
              setError(`Successfully loaded ${loadedTeams.length} teams from ${new Set(loadedTeams.map(t => t.club)).size} clubs`);
              
            } catch (err) {
              setError('Error loading sheet: ' + err.message);
              console.error(err);
            }
            
            setLoadingSheet(false);
          };

          const generateSampleTeams = () => {
            const clubs = ['Rovers', 'United', 'Wasps', 'Tigers', 'Saints', 'Warriors', 'Chiefs', 'Dragons'];
            const sampleTeams = [];
            
            for (let i = 0; i < 64; i++) {
              const clubIndex = Math.floor(i / 8);
              const teamNumber = (i % 8) + 1;
              sampleTeams.push({
                id: `team-${i}`,
                name: `${clubs[clubIndex]} U7 Team ${teamNumber}`,
                club: clubs[clubIndex],
                pitchAssignment: null
              });
            }
            
            return sampleTeams;
          };

          const isLunchTime = (time) => {
            if (!lunchEnabled) return false;
            return time >= lunchStart && time < lunchEnd;
          };

          const getNextAvailableTime = (time) => {
            if (isLunchTime(time)) {
              return lunchEnd;
            }
            return time;
          };

          const addMinutes = (time, mins) => {
            const [h, m] = time.split(':').map(Number);
            const total = h * 60 + m + mins;
            return `${String(Math.floor(total / 60)).padStart(2, '0')}:${String(total % 60).padStart(2, '0')}`;
          };

          const computePitchGrid = (totalPitches, numColumns = 4) => {
            const pitchesPerColumn = Math.ceil(totalPitches / numColumns);
            const positions = {};
            let pitchNum = 1;
            for (let col = 0; col < numColumns && pitchNum <= totalPitches; col++) {
              for (let row = 0; row < pitchesPerColumn && pitchNum <= totalPitches; row++) {
                const actualRow = (col % 2 === 0)
                  ? (pitchesPerColumn - 1 - row)
                  : row;
                positions[pitchNum] = [actualRow, col];
                pitchNum++;
              }
            }
            return positions;
          };

          const computeZones = (totalPitches) => {
            const numZones = Math.floor(totalPitches / 2);
            const zoneLabels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const zoneList = [];
            for (let z = 0; z < numZones; z++) {
              zoneList.push({
                id: zoneLabels[z],
                pitches: [z * 2 + 1, z * 2 + 2],
                teams: [],
              });
            }
            return zoneList;
          };

          const computeZoneAdjacency = (zoneList, pitchGrid) => {
            const zoneCenters = zoneList.map(z => {
              const p1 = pitchGrid[z.pitches[0]] || [0, 0];
              const p2 = pitchGrid[z.pitches[1]] || [0, 0];
              return { id: z.id, row: (p1[0] + p2[0]) / 2, col: (p1[1] + p2[1]) / 2 };
            });
            const adjacencyMap = {};
            zoneCenters.forEach(zc => {
              adjacencyMap[zc.id] = zoneCenters
                .filter(other => other.id !== zc.id)
                .sort((a, b) => {
                  const distA = Math.abs(a.row - zc.row) + Math.abs(a.col - zc.col);
                  const distB = Math.abs(b.row - zc.row) + Math.abs(b.col - zc.col);
                  return distA - distB;
                })
                .map(other => other.id);
            });
            return adjacencyMap;
          };

          const assignTeamsToZones = (teamList, zoneList) => {
            const numZones = zoneList.length;
            const maxPerZone = Math.ceil(teamList.length / numZones);
            const clubGroups = {};
            teamList.forEach(t => {
              if (!clubGroups[t.club]) clubGroups[t.club] = [];
              clubGroups[t.club].push(t);
            });
            const sortedClubs = Object.keys(clubGroups).sort(
              (a, b) => clubGroups[b].length - clubGroups[a].length
            );
            zoneList.forEach(z => { z.teams = []; });
            let globalOffset = 0;
            sortedClubs.forEach(club => {
              const clubTeams = clubGroups[club];
              let zoneIdx = globalOffset;
              clubTeams.forEach(team => {
                let placed = false;
                for (let attempt = 0; attempt < numZones; attempt++) {
                  const candidateIdx = (zoneIdx + attempt) % numZones;
                  if (zoneList[candidateIdx].teams.length < maxPerZone) {
                    zoneList[candidateIdx].teams.push(team);
                    team.zone = zoneList[candidateIdx].id;
                    zoneIdx = (candidateIdx + 1) % numZones;
                    placed = true;
                    break;
                  }
                }
                if (!placed) {
                  const leastFull = zoneList.reduce((a, b) => a.teams.length <= b.teams.length ? a : b);
                  leastFull.teams.push(team);
                  team.zone = leastFull.id;
                }
              });
              globalOffset = (globalOffset + 1) % numZones;
            });
            return zoneList;
          };

          const findBestMatch = (candidates, playedMatchups, clubMatchupsPerTeam, teamFixtureCounts, targetRounds, adjacency) => {
            let bestMatch = null;
            let bestScore = -Infinity;
            for (let i = 0; i < candidates.length; i++) {
              const t1 = candidates[i];
              for (let j = i + 1; j < candidates.length; j++) {
                const t2 = candidates[j];
                const matchupKey = [t1.id, t2.id].sort().join('-');
                if (t1.club === t2.club) continue;
                if (playedMatchups.has(matchupKey)) continue;
                const t1PlayedClub = clubMatchupsPerTeam[t1.id].has(t2.club);
                const t2PlayedClub = clubMatchupsPerTeam[t2.id].has(t1.club);
                let score = 1000;
                if (!t1PlayedClub && !t2PlayedClub) score += 100;
                else if (!t1PlayedClub || !t2PlayedClub) score += 50;
                else score -= 100;
                score += (targetRounds - teamFixtureCounts[t1.id]) * 20;
                score += (targetRounds - teamFixtureCounts[t2.id]) * 20;
                score += (10 - clubMatchupsPerTeam[t1.id].size) * 5;
                score += (10 - clubMatchupsPerTeam[t2.id].size) * 5;
                if (t1.zone && t2.zone) {
                  if (t1.zone === t2.zone) {
                    score += 200;
                  } else if (adjacency && adjacency[t1.zone] && adjacency[t1.zone].indexOf(t2.zone) < 2) {
                    score += 50;
                  }
                }
                if (score > bestScore) {
                  bestScore = score;
                  bestMatch = { t1, t2, matchupKey };
                }
              }
            }
            return bestMatch;
          };

          const assignReferees = (fixtureList, zoneList) => {
            // Build lookup: pitch number -> zone
            const pitchToZone = {};
            zoneList.forEach(z => z.pitches.forEach(p => { pitchToZone[p] = z; }));

            // Track how many times each team has refereed (for balancing)
            const refereeCounts = {};
            zoneList.forEach(z => z.teams.forEach(t => { refereeCounts[t.id] = 0; }));

            // Group fixtures by round
            const rounds = [...new Set(fixtureList.map(f => f.round))].sort((a, b) => a - b);

            rounds.forEach(round => {
              const roundFixtures = fixtureList.filter(f => f.round === round);
              const playingTeams = new Set();
              roundFixtures.forEach(f => {
                playingTeams.add(f.team1.id);
                playingTeams.add(f.team2.id);
              });

              const assignedRefsThisRound = new Set();

              // Sort fixtures so zones with fewer available referees are processed first
              // (greedy approach - hardest to fill first)
              const sortedFixtures = [...roundFixtures].sort((a, b) => {
                const zoneA = pitchToZone[a.pitch];
                const zoneB = pitchToZone[b.pitch];
                const availA = zoneA ? zoneA.teams.filter(t =>
                  t.id !== a.team1.id && t.id !== a.team2.id
                ).length : 0;
                const availB = zoneB ? zoneB.teams.filter(t =>
                  t.id !== b.team1.id && t.id !== b.team2.id
                ).length : 0;
                return availA - availB;
              });

              sortedFixtures.forEach(fixture => {
                const zone = pitchToZone[fixture.pitch];
                if (!zone) {
                  fixture.referee = null;
                  fixture.refereeConflict = true;
                  return;
                }

                // Candidates: teams in the zone, not playing THIS match, not already refereeing this round
                const candidates = zone.teams.filter(t =>
                  t.id !== fixture.team1.id &&
                  t.id !== fixture.team2.id &&
                  !assignedRefsThisRound.has(t.id)
                );

                // Split into preferred (not playing at all this round) and fallback (playing another match)
                const preferred = candidates.filter(t => !playingTeams.has(t.id));
                const fallback = candidates.filter(t => playingTeams.has(t.id));

                const pickLeastUsed = (list) => {
                  return list.sort((a, b) => (refereeCounts[a.id] || 0) - (refereeCounts[b.id] || 0))[0];
                };

                if (preferred.length > 0) {
                  const ref = pickLeastUsed(preferred);
                  fixture.referee = { id: ref.id, name: ref.name, club: ref.club, zone: ref.zone };
                  fixture.refereeConflict = false;
                  refereeCounts[ref.id] = (refereeCounts[ref.id] || 0) + 1;
                  assignedRefsThisRound.add(ref.id);
                } else if (fallback.length > 0) {
                  const ref = pickLeastUsed(fallback);
                  fixture.referee = { id: ref.id, name: ref.name, club: ref.club, zone: ref.zone };
                  fixture.refereeConflict = true;
                  refereeCounts[ref.id] = (refereeCounts[ref.id] || 0) + 1;
                  assignedRefsThisRound.add(ref.id);
                } else {
                  // No one available in zone - try adjacent zones as last resort
                  fixture.referee = null;
                  fixture.refereeConflict = true;
                }
              });
            });

            return fixtureList;
          };

          const generateFixtures = async () => {
            setLoading(true);
            setError('');

            try {
              const teamList = teams.length > 0 ? [...teams] : generateSampleTeams();

              // Phase 0: Zone setup
              const minTeamsPerZone = 3;
              const maxZonesByPitches = Math.floor(numPitches / 2);
              const maxZonesByTeams = Math.floor(teamList.length / minTeamsPerZone);
              const activeZoneCount = Math.min(maxZonesByPitches, maxZonesByTeams);
              const activePitchCount = activeZoneCount * 2;

              const zoneList = computeZones(activePitchCount);
              const pitchGrid = computePitchGrid(activePitchCount);
              const adjacency = computeZoneAdjacency(zoneList, pitchGrid);
              assignTeamsToZones(teamList, zoneList);

              // Tracking structures
              const allFixtures = [];
              const teamFixtureCounts = {};
              const playedMatchups = new Set();
              const clubMatchupsPerTeam = {};

              teamList.forEach(t => {
                teamFixtureCounts[t.id] = 0;
                clubMatchupsPerTeam[t.id] = new Set();
              });

              let totalRounds = 0;
              const maxRounds = numRounds * 3;
              let currentTime = startTime;

              const recordMatch = (t1, t2, matchupKey, usedSet) => {
                playedMatchups.add(matchupKey);
                teamFixtureCounts[t1.id]++;
                teamFixtureCounts[t2.id]++;
                usedSet.add(t1.id);
                usedSet.add(t2.id);
                clubMatchupsPerTeam[t1.id].add(t2.club);
                clubMatchupsPerTeam[t2.id].add(t1.club);
              };

              // Phase 1 & 2: Round-by-round generation
              while (totalRounds < maxRounds) {
                const teamsNeedingMatches = teamList.filter(t => teamFixtureCounts[t.id] < numRounds);
                if (teamsNeedingMatches.length === 0) break;

                const usedTeamsThisRound = new Set();
                const roundFixtures = [];
                const filledPitches = new Set();

                // Phase 1: Intra-zone matches
                for (const zone of zoneList) {
                  for (let pitchSlot = 0; pitchSlot < 2; pitchSlot++) {
                    const pitch = zone.pitches[pitchSlot];
                    const availableInZone = zone.teams.filter(
                      t => !usedTeamsThisRound.has(t.id) && teamFixtureCounts[t.id] < numRounds
                    );
                    if (availableInZone.length < 2) break;

                    const match = findBestMatch(availableInZone, playedMatchups, clubMatchupsPerTeam, teamFixtureCounts, numRounds, adjacency);
                    if (!match) break;

                    const { t1, t2, matchupKey } = match;
                    roundFixtures.push({
                      id: `fixture-${totalRounds}-${pitch}`,
                      round: totalRounds + 1,
                      pitch,
                      time: currentTime,
                      team1: t1,
                      team2: t2,
                      zone: zone.id,
                      isCrossZone: false,
                    });
                    recordMatch(t1, t2, matchupKey, usedTeamsThisRound);
                    filledPitches.add(pitch);
                  }
                }

                // Phase 2: Cross-zone backfill for unfilled pitch slots
                for (const zone of zoneList) {
                  for (const pitch of zone.pitches) {
                    if (filledPitches.has(pitch)) continue;

                    // Gather candidates from all zones, ordered by proximity to this zone
                    const zoneOrder = [zone.id, ...(adjacency[zone.id] || [])];
                    const candidates = [];
                    for (const zId of zoneOrder) {
                      const z = zoneList.find(zz => zz.id === zId);
                      if (!z) continue;
                      z.teams.forEach(t => {
                        if (!usedTeamsThisRound.has(t.id) && teamFixtureCounts[t.id] < numRounds) {
                          candidates.push(t);
                        }
                      });
                    }
                    if (candidates.length < 2) continue;

                    const match = findBestMatch(candidates, playedMatchups, clubMatchupsPerTeam, teamFixtureCounts, numRounds, adjacency);
                    if (!match) continue;

                    const { t1, t2, matchupKey } = match;
                    roundFixtures.push({
                      id: `fixture-${totalRounds}-${pitch}`,
                      round: totalRounds + 1,
                      pitch,
                      time: currentTime,
                      team1: t1,
                      team2: t2,
                      zone: zone.id,
                      isCrossZone: t1.zone !== t2.zone,
                    });
                    recordMatch(t1, t2, matchupKey, usedTeamsThisRound);
                    filledPitches.add(pitch);
                  }
                }

                if (roundFixtures.length > 0) {
                  allFixtures.push(...roundFixtures);
                } else {
                  break;
                }

                totalRounds++;
                let nextTime = addMinutes(currentTime, matchDuration);
                currentTime = getNextAvailableTime(nextTime);
              }

              if (allFixtures.length === 0) {
                setError('Failed to generate fixtures. Try adjusting the number of pitches or rounds.');
              } else {
                // Assign referees to all fixtures
                assignReferees(allFixtures, zoneList);

                setFixtures(allFixtures);
                setTeams(teamList);
                setZones(zoneList);
                await saveFixtures(allFixtures, teamList, zoneList);

                const fixtureCounts = Object.values(teamFixtureCounts);
                const minFixtures = Math.min(...fixtureCounts);
                const maxFixtures = Math.max(...fixtureCounts);
                const avgFixtures = (fixtureCounts.reduce((a, b) => a + b, 0) / fixtureCounts.length).toFixed(1);
                const teamsWithTarget = fixtureCounts.filter(c => c === numRounds).length;

                const intraZoneCount = allFixtures.filter(f => !f.isCrossZone).length;
                const crossZoneCount = allFixtures.filter(f => f.isCrossZone).length;
                const intraPercent = allFixtures.length > 0 ? Math.round(intraZoneCount / allFixtures.length * 100) : 0;

                const conflictCount = allFixtures.filter(f => f.refereeConflict).length;
                const unassignedCount = allFixtures.filter(f => !f.referee).length;

                let summary = `Generated ${allFixtures.length} fixtures across ${totalRounds} rounds in ${zoneList.length} zones. `;
                summary += `Teams have ${minFixtures}-${maxFixtures} matches (avg: ${avgFixtures}). `;
                summary += `${teamsWithTarget}/${teamList.length} teams have exactly ${numRounds} matches. `;
                summary += `${intraPercent}% intra-zone, ${100 - intraPercent}% cross-zone. `;
                summary += `Referees: ${allFixtures.length - conflictCount} clean, ${conflictCount - unassignedCount} conflicts, ${unassignedCount} unassigned.`;

                setError(summary);
                console.log(summary);
              }
            } catch (err) {
              setError('Error generating fixtures: ' + err.message);
              console.error(err);
            }

            setLoading(false);
          };

          // Push notifications: alert 2 minutes before a match starts
          useEffect(() => {
            if (!notificationsEnabled || !selectedTeam || view !== 'public') return;
            const interval = setInterval(() => {
              const now = new Date();
              const currentMins = now.getHours() * 60 + now.getMinutes();
              const teamFix = fixtures.filter(f => f.team1.id === selectedTeam.id || f.team2.id === selectedTeam.id);
              teamFix.forEach(f => {
                const [h, m] = f.time.split(':').map(Number);
                const fixMins = h * 60 + m;
                const diff = fixMins - currentMins;
                if (diff >= 0 && diff <= 2 && !notifiedFixtures.has(f.id)) {
                  const opponent = f.team1.id === selectedTeam.id ? f.team2 : f.team1;
                  new Notification('Match Starting Soon!', {
                    body: `${selectedTeam.name} vs ${opponent.name} on Pitch ${f.pitch} at ${f.time}`,
                    icon: 'ðŸ‰',
                    tag: f.id,
                  });
                  setNotifiedFixtures(prev => new Set([...prev, f.id]));
                }
              });
            }, 30000);
            return () => clearInterval(interval);
          }, [notificationsEnabled, selectedTeam, fixtures, view, notifiedFixtures]);

          const enableNotifications = async () => {
            if (!('Notification' in window)) {
              alert('Notifications are not supported in this browser');
              return;
            }
            const perm = await Notification.requestPermission();
            if (perm === 'granted') {
              setNotificationsEnabled(true);
              new Notification('Notifications Enabled', { body: "You'll be notified 2 minutes before your team's matches." });
            }
          };

          const filteredTeams = teams.filter(t =>
            t.name.toLowerCase().includes(searchTerm.toLowerCase())
          );

          const getTeamFixtures = (teamId) => {
            return fixtures.filter(f => 
              f.team1.id === teamId || f.team2.id === teamId
            ).sort((a, b) => a.time.localeCompare(b.time));
          };

          const getCurrentAndNext = () => {
            const now = new Date();
            const currentTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;

            const current = fixtures.filter(f => f.time <= currentTime &&
              currentTime < addMinutes(f.time, matchDuration));
            const upcoming = fixtures.filter(f => f.time > currentTime)
              .sort((a, b) => a.time.localeCompare(b.time))
              .slice(0, numPitches);

            // If no current or upcoming matches, we're outside schedule times
            // Show all fixtures so the page isn't blank
            if (current.length === 0 && upcoming.length === 0 && fixtures.length > 0) {
              const allSorted = [...fixtures].sort((a, b) => a.time.localeCompare(b.time));
              return { current: [], upcoming: [], allFixtures: allSorted, outsideSchedule: true };
            }

            return { current, upcoming, allFixtures: [], outsideSchedule: false };
          };
           const downloadFixturesAsExcel = async () => {
            try {
              if (!window.XLSX) {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                await new Promise((resolve, reject) => {
                  script.onload = resolve;
                  script.onerror = reject;
                  document.head.appendChild(script);
                });
              }

              const wb = window.XLSX.utils.book_new();

              const fixtureData = [['Round', 'Time', 'Pitch', 'Zone', 'Team 1', 'Team 2', 'Club 1', 'Club 2', 'Cross-Zone', 'Referee', 'Referee Club', 'Ref Conflict']];
              fixtures.forEach(f => {
                fixtureData.push([f.round, f.time, f.pitch, f.zone || '', f.team1.name, f.team2.name, f.team1.club, f.team2.club, f.isCrossZone ? 'Yes' : '',
                  f.referee ? f.referee.name : 'UNASSIGNED', f.referee ? f.referee.club : '', f.refereeConflict ? 'YES' : '']);
              });
              const wsFixtures = window.XLSX.utils.aoa_to_sheet(fixtureData);
              window.XLSX.utils.book_append_sheet(wb, wsFixtures, 'All Fixtures');

              const teamData = [['Team', 'Club', 'Home Zone', 'Round', 'Time', 'Pitch', 'Zone', 'Opponent', 'Opponent Club', 'Referee', 'Ref Conflict']];
              teams.forEach(team => {
                const teamFixtures = fixtures.filter(f => f.team1.id === team.id || f.team2.id === team.id)
                  .sort((a, b) => a.time.localeCompare(b.time));
                teamFixtures.forEach(f => {
                  const opponent = f.team1.id === team.id ? f.team2 : f.team1;
                  teamData.push([team.name, team.club, team.zone || '', f.round, f.time, f.pitch, f.zone || '', opponent.name, opponent.club,
                    f.referee ? f.referee.name : 'UNASSIGNED', f.refereeConflict ? 'YES' : '']);
                });
              });
              const wsTeams = window.XLSX.utils.aoa_to_sheet(teamData);
              window.XLSX.utils.book_append_sheet(wb, wsTeams, 'By Team');

              const rounds = [...new Set(fixtures.map(f => f.round))].sort((a, b) => a - b);
              const roundData = [['Round', 'Time', 'Pitch', 'Zone', 'Team 1', 'Team 2', 'Referee', 'Ref Conflict']];
              rounds.forEach(round => {
                const roundFixtures = fixtures.filter(f => f.round === round).sort((a, b) => a.pitch - b.pitch);
                roundFixtures.forEach(f => {
                  roundData.push([f.round, f.time, f.pitch, f.zone || '', f.team1.name, f.team2.name,
                    f.referee ? f.referee.name : 'UNASSIGNED', f.refereeConflict ? 'YES' : '']);
                });
                if (round < rounds.length) {
                  roundData.push(['', '', '', '', '', '', '', '']);
                }
              });
              const wsRounds = window.XLSX.utils.aoa_to_sheet(roundData);
              window.XLSX.utils.book_append_sheet(wb, wsRounds, 'By Round');

              const pitches = [...new Set(fixtures.map(f => f.pitch))].sort((a, b) => a - b);
              const pitchData = [['Pitch', 'Zone', 'Time', 'Round', 'Team 1', 'Team 2', 'Referee', 'Ref Conflict']];
              pitches.forEach(pitch => {
                const pitchFixtures = fixtures.filter(f => f.pitch === pitch).sort((a, b) => a.time.localeCompare(b.time));
                const pitchZone = zones.find(z => z.pitches.includes(pitch));
                pitchFixtures.forEach(f => {
                  pitchData.push([f.pitch, pitchZone ? pitchZone.id : '', f.time, f.round, f.team1.name, f.team2.name,
                    f.referee ? f.referee.name : 'UNASSIGNED', f.refereeConflict ? 'YES' : '']);
                });
                if (pitch < pitches.length) {
                  pitchData.push(['', '', '', '', '', '', '', '']);
                }
              });
              const wsPitches = window.XLSX.utils.aoa_to_sheet(pitchData);
              window.XLSX.utils.book_append_sheet(wb, wsPitches, 'By Pitch');

              const allTimes = [...new Set(fixtures.map(f => f.time))].sort();
              const matrixHeaders = ['Team', 'Zone'];
              allTimes.forEach(t => { matrixHeaders.push(t + ' (Play)'); matrixHeaders.push(t + ' (Ref)'); });
              const matrixData = [matrixHeaders];
              teams.forEach(team => {
                const row = [team.name, team.zone || ''];
                allTimes.forEach(time => {
                  const playFixture = fixtures.find(f => f.time === time && (f.team1.id === team.id || f.team2.id === team.id));
                  const refFixture = fixtures.find(f => f.time === time && f.referee && f.referee.id === team.id);
                  if (playFixture) {
                    const opponent = playFixture.team1.id === team.id ? playFixture.team2 : playFixture.team1;
                    row.push('vs ' + opponent.name);
                  } else {
                    row.push('');
                  }
                  if (refFixture) {
                    const label = refFixture.refereeConflict ? 'REF* (CONFLICT)' : 'REF';
                    row.push(label);
                  } else {
                    row.push('');
                  }
                });
                matrixData.push(row);
              });
              const wsMatrix = window.XLSX.utils.aoa_to_sheet(matrixData);
              window.XLSX.utils.book_append_sheet(wb, wsMatrix, 'Team Schedule Matrix');

              // Referee Schedule sheet
              const refData = [['Team', 'Club', 'Zone', 'Total Ref Duties', 'Round', 'Time', 'Pitch', 'Match', 'Conflict']];
              teams.forEach(team => {
                const refFixtures = fixtures.filter(f => f.referee && f.referee.id === team.id)
                  .sort((a, b) => a.time.localeCompare(b.time));
                if (refFixtures.length === 0) {
                  refData.push([team.name, team.club, team.zone || '', 0, '', '', '', '', '']);
                } else {
                  refFixtures.forEach((f, idx) => {
                    refData.push([
                      idx === 0 ? team.name : '', idx === 0 ? team.club : '', idx === 0 ? (team.zone || '') : '',
                      idx === 0 ? refFixtures.length : '',
                      f.round, f.time, f.pitch,
                      `${f.team1.name} vs ${f.team2.name}`,
                      f.refereeConflict ? 'YES - team playing simultaneously' : '',
                    ]);
                  });
                }
              });
              const wsRef = window.XLSX.utils.aoa_to_sheet(refData);
              window.XLSX.utils.book_append_sheet(wb, wsRef, 'Referee Schedule');

              if (zones.length > 0) {
                const zoneSheetData = [['Zone', 'Pitches', 'Teams', 'Team Names', 'Clubs Represented', 'Intra-Zone Matches', 'Cross-Zone Matches', 'Referee Conflicts']];
                zones.forEach(zone => {
                  const zoneFixtures = fixtures.filter(f => f.zone === zone.id);
                  const intraCount = zoneFixtures.filter(f => !f.isCrossZone).length;
                  const crossCount = zoneFixtures.filter(f => f.isCrossZone).length;
                  const refConflicts = zoneFixtures.filter(f => f.refereeConflict).length;
                  const clubs = [...new Set(zone.teams.map(t => t.club))];
                  zoneSheetData.push([
                    zone.id,
                    zone.pitches.join(', '),
                    zone.teams.length,
                    zone.teams.map(t => t.name).join(', '),
                    clubs.join(', '),
                    intraCount,
                    crossCount,
                    refConflicts,
                  ]);
                });
                const wsZones = window.XLSX.utils.aoa_to_sheet(zoneSheetData);
                window.XLSX.utils.book_append_sheet(wb, wsZones, 'Zone Summary');
              }

              window.XLSX.writeFile(wb, 'Rugby_Festival_Fixtures.xlsx');
            } catch (err) {
              setError('Error generating Excel file: ' + err.message);
              console.error(err);
            }
          };

          const loadJsPDF = async () => {
            if (window.jspdf && window.jspdf.jsPDF && typeof window.jspdf.jsPDF.API.autoTable === 'function') return;
            const loadScript = (src) => new Promise((resolve, reject) => {
              const s = document.createElement('script');
              s.src = src;
              s.onload = resolve;
              s.onerror = () => reject(new Error('Failed to load ' + src));
              document.head.appendChild(s);
            });
            if (!window.jspdf) {
              await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js');
            }
            if (!window.jspdf.jsPDF || typeof window.jspdf.jsPDF.API.autoTable !== 'function') {
              await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.4/jspdf.plugin.autotable.min.js');
            }
          };

          const downloadClubPackPDF = async (clubName) => {
            try {
              await loadJsPDF();
              const { jsPDF } = window.jspdf;
              const doc = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });
              const pageW = doc.internal.pageSize.getWidth();
              const pageH = doc.internal.pageSize.getHeight();
              const margin = 8;
              const clubTeams = teams.filter(t => t.club === clubName);

              // --- Page 1: Overview + Full Schedule ---
              // Title
              doc.setFontSize(16);
              doc.setFont(undefined, 'bold');
              doc.text(clubName + ' - Festival Pack', pageW / 2, margin + 4, { align: 'center' });
              doc.setFontSize(8);
              doc.setFont(undefined, 'normal');
              doc.text('Generated ' + new Date().toLocaleDateString(), pageW / 2, margin + 9, { align: 'center' });

              // Overview table
              const overviewHead = [['Team', 'Zone', 'Matches', 'Ref Duties', 'Conflicts']];
              const overviewBody = clubTeams.map(team => {
                const matchCount = fixtures.filter(f => f.team1.id === team.id || f.team2.id === team.id).length;
                const refCount = fixtures.filter(f => f.referee && f.referee.id === team.id).length;
                const conflictCount = fixtures.filter(f => f.referee && f.referee.id === team.id && f.refereeConflict).length;
                return [team.name, team.zone || '-', matchCount, refCount, conflictCount];
              });

              doc.autoTable({
                startY: margin + 12,
                head: overviewHead,
                body: overviewBody,
                theme: 'grid',
                styles: { fontSize: 7, cellPadding: 1.5 },
                headStyles: { fillColor: [124, 18, 41], fontSize: 7, cellPadding: 1.5 },
                margin: { left: margin, right: margin },
                tableWidth: 'wrap',
              });

              // Full schedule table: all teams interleaved by time
              const scheduleHead = [['Team', 'Time', 'Type', 'Pitch', 'Zone', 'Detail', 'Note']];
              const scheduleBody = [];
              clubTeams.forEach(team => {
                const items = [];
                fixtures.filter(f => f.team1.id === team.id || f.team2.id === team.id).forEach(f => {
                  const opp = f.team1.id === team.id ? f.team2 : f.team1;
                  items.push({ time: f.time, type: 'PLAY', pitch: f.pitch, zone: f.zone || '', detail: 'vs ' + opp.name + ' (' + opp.club + ')', note: '' });
                });
                fixtures.filter(f => f.referee && f.referee.id === team.id).forEach(f => {
                  items.push({
                    time: f.time, type: 'REF', pitch: f.pitch, zone: f.zone || '',
                    detail: f.team1.name + ' vs ' + f.team2.name,
                    note: f.refereeConflict ? 'CONFLICT' : '',
                  });
                });
                items.sort((a, b) => a.time.localeCompare(b.time));
                items.forEach((s, idx) => {
                  scheduleBody.push([idx === 0 ? team.name : '', s.time, s.type, s.pitch, s.zone, s.detail, s.note]);
                });
                scheduleBody.push(['', '', '', '', '', '', '']);
              });

              doc.autoTable({
                startY: doc.lastAutoTable.finalY + 4,
                head: scheduleHead,
                body: scheduleBody,
                theme: 'grid',
                styles: { fontSize: 6.5, cellPadding: 1.2 },
                headStyles: { fillColor: [124, 18, 41], fontSize: 6.5, cellPadding: 1.2 },
                columnStyles: {
                  0: { cellWidth: 30 },
                  1: { cellWidth: 16 },
                  2: { cellWidth: 12 },
                  3: { cellWidth: 14 },
                  4: { cellWidth: 14 },
                  6: { cellWidth: 22 },
                },
                margin: { left: margin, right: margin },
                didParseCell: (data) => {
                  if (data.section === 'body' && data.row.raw[6] === 'CONFLICT') {
                    data.cell.styles.textColor = [220, 38, 38];
                    data.cell.styles.fontStyle = 'bold';
                  }
                  if (data.section === 'body' && data.row.raw[2] === 'REF') {
                    data.cell.styles.fillColor = [254, 243, 199];
                  }
                },
              });

              const safeName = clubName.replace(/[^a-zA-Z0-9]/g, '_');
              doc.save(safeName + '_Festival_Pack.pdf');
            } catch (err) {
              setError('Error generating club pack PDF: ' + err.message);
              console.error(err);
            }
          };

          const downloadTeamFixturePDF = async (team) => {
            setPdfLoading(true);
            try {
              await loadJsPDF();
              const { jsPDF } = window.jspdf;
              const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
              const pageW = doc.internal.pageSize.getWidth();
              const margin = 10;

              // Title
              doc.setFontSize(18);
              doc.setFont(undefined, 'bold');
              doc.setTextColor(124, 18, 41);
              doc.text(team.name, pageW / 2, margin + 6, { align: 'center' });
              doc.setFontSize(10);
              doc.setFont(undefined, 'normal');
              doc.setTextColor(100, 100, 100);
              doc.text(team.club + (team.zone ? '  |  Zone ' + team.zone : ''), pageW / 2, margin + 12, { align: 'center' });

              // Build combined schedule
              const teamMatches = fixtures.filter(f => f.team1.id === team.id || f.team2.id === team.id);
              const refDuties = fixtures.filter(f => f.referee && f.referee.id === team.id);
              const schedule = [];

              teamMatches.forEach((f, idx) => {
                const opp = f.team1.id === team.id ? f.team2 : f.team1;
                const isAway = team.zone && f.zone !== team.zone;
                schedule.push({
                  time: f.time, type: 'MATCH ' + (idx + 1), pitch: 'Pitch ' + f.pitch,
                  detail: 'vs ' + opp.name + ' (' + opp.club + ')',
                  note: isAway ? 'AWAY - Zone ' + f.zone : (f.zone ? 'Zone ' + f.zone : ''),
                  isRef: false, isConflict: false
                });
              });
              refDuties.forEach(f => {
                schedule.push({
                  time: f.time, type: 'REF DUTY', pitch: 'Pitch ' + f.pitch,
                  detail: f.team1.name + ' vs ' + f.team2.name,
                  note: f.refereeConflict ? 'CONFLICT' : '',
                  isRef: true, isConflict: f.refereeConflict
                });
              });
              schedule.sort((a, b) => a.time.localeCompare(b.time) || (a.isRef ? 1 : -1));

              const tableHead = [['Time', 'Type', 'Location', 'Detail', 'Note']];
              const tableBody = schedule.map(s => [s.time, s.type, s.pitch, s.detail, s.note]);

              doc.autoTable({
                startY: margin + 18,
                head: tableHead,
                body: tableBody,
                theme: 'grid',
                styles: { fontSize: 9, cellPadding: 3 },
                headStyles: { fillColor: [124, 18, 41], fontSize: 9, cellPadding: 3, halign: 'center' },
                columnStyles: {
                  0: { cellWidth: 18, halign: 'center', fontStyle: 'bold' },
                  1: { cellWidth: 24, halign: 'center' },
                  2: { cellWidth: 22, halign: 'center' },
                  3: { cellWidth: 'auto' },
                  4: { cellWidth: 30 },
                },
                margin: { left: margin, right: margin },
                didParseCell: (data) => {
                  if (data.section === 'body') {
                    const row = data.row.raw;
                    // Ref duty rows get blue background
                    if (row[1] === 'REF DUTY') {
                      data.cell.styles.fillColor = [219, 234, 254];
                    }
                    // Conflict note in red
                    if (row[4] === 'CONFLICT') {
                      data.cell.styles.textColor = [220, 38, 38];
                      data.cell.styles.fontStyle = 'bold';
                    }
                    // Away note in amber
                    if (typeof row[4] === 'string' && row[4].startsWith('AWAY')) {
                      data.cell.styles.textColor = [180, 83, 9];
                      data.cell.styles.fontStyle = 'bold';
                    }
                  }
                },
              });

              // Footer
              const finalY = doc.lastAutoTable.finalY + 6;
              doc.setFontSize(7);
              doc.setTextColor(150, 150, 150);
              doc.text('Generated ' + new Date().toLocaleDateString(), pageW / 2, finalY, { align: 'center' });

              const safeName = team.name.replace(/[^a-zA-Z0-9]/g, '_');
              doc.save(safeName + '_Fixtures.pdf');
            } catch (err) {
              console.error(err);
              alert('Unable to generate PDF. Please try again or use a different browser.\n\n' + err.message);
            } finally {
              setPdfLoading(false);
            }
          };

          const downloadClubPack = async (clubName) => {
            try {
              if (!window.XLSX) {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                await new Promise((resolve, reject) => {
                  script.onload = resolve;
                  script.onerror = reject;
                  document.head.appendChild(script);
                });
              }

              const wb = window.XLSX.utils.book_new();
              const clubTeams = teams.filter(t => t.club === clubName);

              // Sheet 1: Club Overview
              const overviewData = [
                [clubName + ' - Festival Pack'],
                [''],
                ['Team', 'Zone', 'Total Matches', 'Total Ref Duties', 'Ref Conflicts'],
              ];
              clubTeams.forEach(team => {
                const matchCount = fixtures.filter(f => f.team1.id === team.id || f.team2.id === team.id).length;
                const refCount = fixtures.filter(f => f.referee && f.referee.id === team.id).length;
                const conflictCount = fixtures.filter(f => f.referee && f.referee.id === team.id && f.refereeConflict).length;
                overviewData.push([team.name, team.zone || '', matchCount, refCount, conflictCount]);
              });
              const wsOverview = window.XLSX.utils.aoa_to_sheet(overviewData);
              window.XLSX.utils.book_append_sheet(wb, wsOverview, 'Overview');

              // Sheet 2: Full Schedule (matches + ref duties combined, sorted by time)
              const scheduleData = [['Team', 'Time', 'Activity', 'Pitch', 'Zone', 'Detail', 'Conflict']];
              clubTeams.forEach(team => {
                const schedule = [];
                const teamFixtures = fixtures.filter(f => f.team1.id === team.id || f.team2.id === team.id);
                teamFixtures.forEach(f => {
                  const opp = f.team1.id === team.id ? f.team2 : f.team1;
                  schedule.push({ time: f.time, activity: 'PLAY', pitch: f.pitch, zone: f.zone, detail: `vs ${opp.name} (${opp.club})`, conflict: '' });
                });
                const refFixtures = fixtures.filter(f => f.referee && f.referee.id === team.id);
                refFixtures.forEach(f => {
                  schedule.push({
                    time: f.time, activity: 'REFEREE', pitch: f.pitch, zone: f.zone,
                    detail: `${f.team1.name} vs ${f.team2.name}`,
                    conflict: f.refereeConflict ? 'YES - your team playing simultaneously' : '',
                  });
                });
                schedule.sort((a, b) => a.time.localeCompare(b.time));
                schedule.forEach((s, idx) => {
                  scheduleData.push([idx === 0 ? team.name : '', s.time, s.activity, s.pitch, s.zone || '', s.detail, s.conflict]);
                });
                scheduleData.push(['', '', '', '', '', '', '']);
              });
              const wsSchedule = window.XLSX.utils.aoa_to_sheet(scheduleData);
              window.XLSX.utils.book_append_sheet(wb, wsSchedule, 'Full Schedule');

              // Sheet 3: Match Fixtures only
              const matchData = [['Team', 'Round', 'Time', 'Pitch', 'Zone', 'Opponent', 'Opponent Club', 'Referee']];
              clubTeams.forEach(team => {
                const teamFixtures = fixtures.filter(f => f.team1.id === team.id || f.team2.id === team.id)
                  .sort((a, b) => a.time.localeCompare(b.time));
                teamFixtures.forEach((f, idx) => {
                  const opp = f.team1.id === team.id ? f.team2 : f.team1;
                  matchData.push([idx === 0 ? team.name : '', f.round, f.time, f.pitch, f.zone || '', opp.name, opp.club,
                    f.referee ? f.referee.name : 'UNASSIGNED']);
                });
                matchData.push(['', '', '', '', '', '', '', '']);
              });
              const wsMatches = window.XLSX.utils.aoa_to_sheet(matchData);
              window.XLSX.utils.book_append_sheet(wb, wsMatches, 'Matches');

              // Sheet 4: Referee Duties only
              const refDutyData = [['Team', 'Round', 'Time', 'Pitch', 'Zone', 'Match', 'Conflict']];
              clubTeams.forEach(team => {
                const refFixtures = fixtures.filter(f => f.referee && f.referee.id === team.id)
                  .sort((a, b) => a.time.localeCompare(b.time));
                if (refFixtures.length === 0) {
                  refDutyData.push([team.name, '', '', '', '', 'No referee duties assigned', '']);
                } else {
                  refFixtures.forEach((f, idx) => {
                    refDutyData.push([
                      idx === 0 ? team.name : '', f.round, f.time, f.pitch, f.zone || '',
                      `${f.team1.name} vs ${f.team2.name}`,
                      f.refereeConflict ? 'YES - team playing simultaneously' : '',
                    ]);
                  });
                }
                refDutyData.push(['', '', '', '', '', '', '']);
              });
              const wsRefDuties = window.XLSX.utils.aoa_to_sheet(refDutyData);
              window.XLSX.utils.book_append_sheet(wb, wsRefDuties, 'Referee Duties');

              const safeName = clubName.replace(/[^a-zA-Z0-9]/g, '_');
              window.XLSX.writeFile(wb, `${safeName}_Festival_Pack.xlsx`);
            } catch (err) {
              setError('Error generating club pack: ' + err.message);
              console.error(err);
            }
          };

          const printFixtures = (mode) => {
            const printWindow = window.open('', '_blank');
            const rounds = [...new Set(fixtures.map(f => f.round))].sort((a, b) => a - b);
            const pitches = [...new Set(fixtures.map(f => f.pitch))].sort((a, b) => a - b);
            let html = `<!DOCTYPE html><html><head><title>Rugby Fixtures - Print</title>
              <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .print-header { text-align: center; margin-bottom: 15px; }
                .print-header h1 { font-size: 18pt; margin: 0; }
                .print-header p { font-size: 10pt; margin: 2px 0; color: #666; }
                table { width: 100%; border-collapse: collapse; font-size: 9pt; margin-bottom: 20px; }
                th, td { border: 1px solid #333; padding: 4px 6px; text-align: left; }
                th { background: #333; color: #fff; font-weight: bold; }
                tr:nth-child(even) { background: #f0f0f0; }
                .conflict { background: #fee2e2 !important; }
                .ref-duty { background: #fef3c7 !important; }
                .page-break { page-break-after: always; }
                h2 { font-size: 14pt; margin: 15px 0 8px 0; border-bottom: 2px solid #333; padding-bottom: 4px; }
                h3 { font-size: 12pt; margin: 10px 0 5px 0; }
                .legend { font-size: 8pt; color: #666; margin-bottom: 10px; }
                @media print { body { margin: 10px; } .conflict { background: #fee2e2 !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; } .ref-duty { background: #fef3c7 !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; } }
              </style></head><body>`;

            if (mode === 'byRound') {
              html += `<div class="print-header"><h1>U7's Waterfall - Fixtures by Round</h1><p>Generated ${new Date().toLocaleDateString()}</p></div>`;
              html += `<p class="legend">* = Referee conflict (referee's team also playing this round)</p>`;
              rounds.forEach((round, idx) => {
                const rf = fixtures.filter(f => f.round === round).sort((a, b) => a.pitch - b.pitch);
                html += `<h2>Round ${round} - ${rf[0]?.time || ''}</h2>`;
                html += `<table><tr><th>Pitch</th><th>Zone</th><th>Team 1</th><th>Team 2</th><th>Referee</th></tr>`;
                rf.forEach(f => {
                  const refText = f.referee ? f.referee.name : 'UNASSIGNED';
                  const rowClass = f.refereeConflict ? ' class="conflict"' : '';
                  html += `<tr${rowClass}><td>${f.pitch}</td><td>${f.zone || ''}</td><td>${f.team1.name}</td><td>${f.team2.name}</td><td>${refText}${f.refereeConflict ? ' *' : ''}</td></tr>`;
                });
                html += `</table>`;
                if (idx < rounds.length - 1 && idx % 3 === 2) html += `<div class="page-break"></div>`;
              });
            } else if (mode === 'byPitch') {
              html += `<div class="print-header"><h1>U7's Waterfall - Pitch Schedules</h1><p>Generated ${new Date().toLocaleDateString()}</p></div>`;
              html += `<p class="legend">* = Referee conflict (referee's team also playing this round)</p>`;
              pitches.forEach((pitch, idx) => {
                const pf = fixtures.filter(f => f.pitch === pitch).sort((a, b) => a.time.localeCompare(b.time));
                const zone = zones.find(z => z.pitches.includes(pitch));
                html += `<h2>Pitch ${pitch}${zone ? ` (Zone ${zone.id})` : ''}</h2>`;
                html += `<table><tr><th>Time</th><th>Round</th><th>Team 1</th><th>Team 2</th><th>Referee</th></tr>`;
                pf.forEach(f => {
                  const refText = f.referee ? f.referee.name : 'UNASSIGNED';
                  const rowClass = f.refereeConflict ? ' class="conflict"' : '';
                  html += `<tr${rowClass}><td>${f.time}</td><td>${f.round}</td><td>${f.team1.name}</td><td>${f.team2.name}</td><td>${refText}${f.refereeConflict ? ' *' : ''}</td></tr>`;
                });
                html += `</table>`;
                if (idx < pitches.length - 1 && idx % 2 === 1) html += `<div class="page-break"></div>`;
              });
            } else if (mode === 'byTeam') {
              html += `<div class="print-header"><h1>U7's Waterfall - Team Schedules</h1><p>Generated ${new Date().toLocaleDateString()}</p></div>`;
              html += `<p class="legend">* = Referee conflict (your team also playing this round). Highlighted rows = referee duty.</p>`;
              const sortedTeams = [...teams].sort((a, b) => a.club.localeCompare(b.club) || a.name.localeCompare(b.name));
              let currentClub = '';
              sortedTeams.forEach((team, idx) => {
                if (team.club !== currentClub) { currentClub = team.club; html += `<h2>${currentClub}</h2>`; }
                const tf = fixtures.filter(f => f.team1.id === team.id || f.team2.id === team.id).sort((a, b) => a.time.localeCompare(b.time));
                const refDuties = fixtures.filter(f => f.referee && f.referee.id === team.id).sort((a, b) => a.time.localeCompare(b.time));
                html += `<h3>${team.name}${team.zone ? ` (Zone ${team.zone})` : ''} - ${tf.length} matches, ${refDuties.length} ref duties</h3>`;
                // Combined schedule: matches + ref duties in time order
                const schedule = [];
                tf.forEach(f => {
                  const opp = f.team1.id === team.id ? f.team2 : f.team1;
                  schedule.push({ time: f.time, pitch: f.pitch, zone: f.zone, type: 'PLAY', detail: `vs ${opp.name}`, conflict: false });
                });
                refDuties.forEach(f => {
                  schedule.push({ time: f.time, pitch: f.pitch, zone: f.zone, type: 'REF', detail: `${f.team1.name} vs ${f.team2.name}`, conflict: f.refereeConflict });
                });
                schedule.sort((a, b) => a.time.localeCompare(b.time) || (a.type === 'PLAY' ? -1 : 1));
                html += `<table><tr><th>Time</th><th>Pitch</th><th>Zone</th><th>Activity</th><th>Detail</th></tr>`;
                schedule.forEach(s => {
                  const rowClass = s.conflict ? ' class="conflict"' : s.type === 'REF' ? ' class="ref-duty"' : '';
                  html += `<tr${rowClass}><td>${s.time}</td><td>${s.pitch}</td><td>${s.zone || ''}</td><td>${s.type}${s.conflict ? ' *' : ''}</td><td>${s.detail}</td></tr>`;
                });
                html += `</table>`;
                if (idx < sortedTeams.length - 1 && idx % 6 === 5) html += `<div class="page-break"></div>`;
              });
            }

            html += `</body></html>`;
            printWindow.document.write(html);
            printWindow.document.close();
            printWindow.focus();
            setTimeout(() => printWindow.print(), 500);
          };

          if (view === 'admin') {
            if (!isAuthenticated) {
              return (
                <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
                  <div className="bg-white rounded-lg shadow-lg p-8 max-w-md w-full">
                    <h1 className="text-2xl font-bold text-gray-900 mb-4">Admin Access</h1>
                    <p className="text-gray-600 mb-6">Please enter the password to access the admin panel.</p>
                    <input
                      type="password"
                      value={passwordInput}
                      onChange={(e) => setPasswordInput(e.target.value)}
                      onKeyPress={(e) => {
                        if (e.key === 'Enter') {
                          if (passwordInput === 'Nissan01') {
                            setIsAuthenticated(true);
                          } else {
                            alert('Incorrect password');
                            setPasswordInput('');
                          }
                        }
                      }}
                      placeholder="Enter password"
                      className="w-full px-4 py-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      autoFocus
                    />
                    <button
                      onClick={() => {
                        if (passwordInput === 'Nissan01') {
                          setIsAuthenticated(true);
                        } else {
                          alert('Incorrect password');
                          setPasswordInput('');
                        }
                      }}
                      className="w-full px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                    >
                      Login
                    </button>
                  </div>
                </div>
              );
            }

            return (
              <div className="min-h-screen bg-gray-50 p-4">
                <div className="max-w-6xl mx-auto">
                  <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <div className="flex items-center justify-between mb-6">
                      <div>
                        <h1 className="text-3xl font-bold text-gray-900">U7's Waterfall</h1>
                        <p className="text-gray-600 mt-1">Generate and manage fixtures</p>
                      </div>
                                    </div>
                    {error && (
                      <div className={`mb-4 p-4 ${error.includes('Successfully') ? 'bg-[#7c1229]/5 border-green-200 text-green-700' : 'bg-red-50 border-red-200 text-red-700'} border rounded-lg`}>
                        {error}
                      </div>
                    )}
                    <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                      <h3 className="font-semibold text-blue-900 mb-3">Load Teams from Google Sheet</h3>
                      <div className="mb-3 flex gap-2">
                        <button onClick={() => setUploadMethod('url')} className={`px-4 py-2 rounded-lg ${uploadMethod === 'url' ? 'bg-blue-600 text-white' : 'bg-white text-blue-600 border border-blue-300'}`}>From URL</button>
                        <button onClick={() => setUploadMethod('file')} className={`px-4 py-2 rounded-lg ${uploadMethod === 'file' ? 'bg-blue-600 text-white' : 'bg-white text-blue-600 border border-blue-300'}`}>Upload File</button>
                      </div>
                      {uploadMethod === 'url' ? (
                        <div className="space-y-3">
                          <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">Google Sheet URL</label>
                            <div className="flex gap-2">
                              <input type="text" value={sheetUrl} onChange={(e) => setSheetUrl(e.target.value)} placeholder="https://docs.google.com/spreadsheets/d/..." className="flex-1 px-3 py-2 border border-gray-300 rounded-lg" />
                              {sheetUrl && (
                                <button onClick={() => setSheetUrl('')} className="px-3 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 text-sm font-medium whitespace-nowrap">
                                  Clear
                                </button>
                              )}
                            </div>
                            <p className="text-xs text-gray-600 mt-1">Make sure your sheet is published to web</p>
                          </div>
                          <button onClick={loadTeamsFromSheet} disabled={loadingSheet || !sheetUrl} className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400">
                            <Download size={18} className={loadingSheet ? 'animate-spin' : ''} />
                            {loadingSheet ? 'Loading...' : 'Load Teams from Sheet'}
                          </button>
                        </div>
                      ) : (
                        <div className="space-y-3">
                          <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">Upload Excel or CSV File</label>
                            <p className="text-xs text-gray-600 mb-2">Download your sheet as Excel (.xlsx) or CSV</p>
                            <input type="file" accept=".csv,.xlsx,.xls" onChange={handleFileUpload} className="w-full px-3 py-2 border border-gray-300 rounded-lg bg-white" />
                          </div>
                        </div>
                      )}
                      {teams.length > 0 && <p className="text-sm text-green-700 font-medium mt-3">âœ“ {teams.length} teams loaded and ready</p>}
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Number of Rounds</label>
                        <input type="number" value={numRounds} onChange={(e) => setNumRounds(parseInt(e.target.value))} className="w-full px-3 py-2 border border-gray-300 rounded-lg" min="4" max="12" />
                        <p className="text-xs text-gray-600 mt-1">Matches per team</p>
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Number of Pitches</label>
                        <input type="number" value={numPitches} onChange={(e) => setNumPitches(parseInt(e.target.value))} className="w-full px-3 py-2 border border-gray-300 rounded-lg" min="4" max="20" />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Match Duration (mins)</label>
                        <input type="number" value={matchDuration} onChange={(e) => setMatchDuration(parseInt(e.target.value))} className="w-full px-3 py-2 border border-gray-300 rounded-lg" min="10" max="20" />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">Start Time</label>
                        <input type="time" value={startTime} onChange={(e) => setStartTime(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                      </div>
                    </div>
                    <div className="mb-6 p-4 bg-amber-50 border border-amber-200 rounded-lg">
                      <div className="flex items-center gap-2 mb-3">
                        <input type="checkbox" id="lunchEnabled" checked={lunchEnabled} onChange={(e) => setLunchEnabled(e.target.checked)} className="w-4 h-4" />
                        <label htmlFor="lunchEnabled" className="font-semibold text-amber-900">Schedule Lunch Break</label>
                      </div>
                      {lunchEnabled && (
                        <div className="grid grid-cols-2 gap-4">
                          <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">Lunch Start</label>
                            <input type="time" value={lunchStart} onChange={(e) => setLunchStart(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                          </div>
                          <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">Lunch End</label>
                            <input type="time" value={lunchEnd} onChange={(e) => setLunchEnd(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" />
                          </div>
                        </div>
                      )}
                    </div>
                    <button onClick={generateFixtures} disabled={loading} className="w-full flex items-center justify-center gap-2 px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-400">
                      <RefreshCw size={20} className={loading ? 'animate-spin' : ''} />
                      {loading ? 'Generating...' : 'Generate Fixtures'}
                    </button>
                  </div>
                  {zones.length > 0 && (
                    <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                      <h2 className="text-2xl font-bold text-gray-900 mb-4">Pitch Layout & Zones</h2>
                      {(() => {
                        const zoneColors = {
                          A: 'bg-red-100 border-red-400 text-red-800',
                          B: 'bg-blue-100 border-blue-400 text-blue-800',
                          C: 'bg-green-100 border-green-400 text-green-800',
                          D: 'bg-yellow-100 border-yellow-400 text-yellow-800',
                          E: 'bg-purple-100 border-purple-400 text-purple-800',
                          F: 'bg-pink-100 border-pink-400 text-pink-800',
                          G: 'bg-indigo-100 border-indigo-400 text-indigo-800',
                          H: 'bg-orange-100 border-orange-400 text-orange-800',
                        };
                        const activePitchCount = zones.length * 2;
                        const grid = computePitchGrid(activePitchCount);
                        const numCols = Math.min(4, Math.ceil(activePitchCount / 4) > 0 ? 4 : 2);
                        const numRows = Math.ceil(activePitchCount / numCols);
                        const pitchToZone = {};
                        zones.forEach(z => { z.pitches.forEach(p => { pitchToZone[p] = z.id; }); });
                        const gridCells = [];
                        for (let r = 0; r < numRows; r++) {
                          for (let c = 0; c < numCols; c++) {
                            const entry = Object.entries(grid).find(([_, pos]) => pos[0] === r && pos[1] === c);
                            gridCells.push(entry ? { pitch: parseInt(entry[0]), row: r, col: c } : null);
                          }
                        }
                        return (
                          <div>
                            <div className="inline-grid gap-2 mb-6" style={{ gridTemplateColumns: `repeat(${numCols}, 1fr)` }}>
                              {gridCells.map((cell, idx) => {
                                if (!cell) return <div key={idx}></div>;
                                const zId = pitchToZone[cell.pitch];
                                const colorClass = zoneColors[zId] || 'bg-gray-100 border-gray-300 text-gray-700';
                                return (
                                  <div key={idx} className={`${colorClass} border-2 rounded-lg p-3 text-center min-w-[80px]`}>
                                    <div className="text-lg font-bold">P{cell.pitch}</div>
                                    <div className="text-xs font-medium">Zone {zId}</div>
                                  </div>
                                );
                              })}
                            </div>
                            <h3 className="text-lg font-bold text-gray-900 mb-3">Zone Assignments</h3>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                              {zones.map(zone => {
                                const colorClass = zoneColors[zone.id] || 'bg-gray-100 border-gray-300';
                                return (
                                  <div key={zone.id} className={`${colorClass} border-2 rounded-lg p-3`}>
                                    <h4 className="font-bold text-lg">Zone {zone.id}</h4>
                                    <p className="text-sm mb-2">Pitches {zone.pitches.join(' & ')}</p>
                                    <ul className="text-sm space-y-1">
                                      {zone.teams.map(t => (
                                        <li key={t.id}>{t.name} <span className="opacity-60">({t.club})</span></li>
                                      ))}
                                    </ul>
                                  </div>
                                );
                              })}
                            </div>
                          </div>
                        );
                      })()}
                    </div>
                  )}
                  {/* Undo History */}
                  {fixtureHistory.length > 0 && (
                    <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                      <h2 className="text-lg font-bold text-gray-900 mb-3">Fixture History (Undo)</h2>
                      <div className="space-y-2">
                        {fixtureHistory.map((entry, idx) => (
                          <div key={idx} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                            <div>
                              <span className="text-sm font-medium text-gray-700">{entry.fixtures.length} fixtures</span>
                              <span className="text-sm text-gray-500 ml-2">saved {new Date(entry.timestamp).toLocaleTimeString()}</span>
                            </div>
                            <button onClick={() => restoreFromHistory(idx)} className="px-3 py-1 bg-amber-500 text-white rounded-lg text-sm hover:bg-amber-600">
                              Restore
                            </button>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {fixtures.length > 0 && (
                    <div className="bg-white rounded-lg shadow-lg p-6">
                      <div className="flex items-center justify-between mb-4 flex-wrap gap-2">
                        <h2 className="text-2xl font-bold text-gray-900">Generated Fixtures ({fixtures.length} matches)</h2>
                        <div className="flex gap-2 flex-wrap">
                          <div className="text-sm text-gray-600 self-center">{teams.length} teams</div>
                          <button onClick={downloadFixturesAsExcel} className="flex items-center gap-2 px-4 py-2 bg-[#7c1229] text-white rounded-lg hover:bg-[#a01638]">
                            <Download size={18} />
                            Excel
                          </button>
                          <div className="relative group">
                            <button className="flex items-center gap-2 px-4 py-2 bg-green-700 text-white rounded-lg hover:bg-green-800">
                              <Download size={18} />
                              Club Pack
                            </button>
                            <div className="absolute right-0 mt-1 bg-white border border-gray-200 rounded-lg shadow-lg hidden group-hover:block z-10 w-64 max-h-60 overflow-y-auto">
                              {[...new Set(teams.map(t => t.club))].sort().map(club => (
                                <div key={club} className="flex items-center justify-between px-4 py-2 border-b border-gray-100 hover:bg-gray-50">
                                  <span className="text-sm text-gray-900 font-medium truncate mr-2">{club}</span>
                                  <div className="flex gap-1 flex-shrink-0">
                                    <button onClick={() => downloadClubPackPDF(club)} className="px-2 py-1 bg-red-700 text-white rounded text-xs font-medium hover:bg-red-800">PDF</button>
                                    <button onClick={() => downloadClubPack(club)} className="px-2 py-1 bg-green-700 text-white rounded text-xs font-medium hover:bg-green-800">Excel</button>
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                          <div className="relative group">
                            <button className="flex items-center gap-2 px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-800">
                              Print
                            </button>
                            <div className="absolute right-0 mt-1 bg-white border border-gray-200 rounded-lg shadow-lg hidden group-hover:block z-10 w-48">
                              <button onClick={() => printFixtures('byRound')} className="w-full px-4 py-2 text-left text-sm hover:bg-gray-50 rounded-t-lg">By Round</button>
                              <button onClick={() => printFixtures('byPitch')} className="w-full px-4 py-2 text-left text-sm hover:bg-gray-50">By Pitch</button>
                              <button onClick={() => printFixtures('byTeam')} className="w-full px-4 py-2 text-left text-sm hover:bg-gray-50 rounded-b-lg">By Team</button>
                            </div>
                          </div>
                        </div>
                      </div>

                      {swapMode && (
                        <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg flex items-center justify-between">
                          <span className="text-blue-800 text-sm font-medium">
                            Swap mode: Click another team to swap with {swapMode.teamName}
                          </span>
                          <button onClick={() => setSwapMode(null)} className="px-3 py-1 bg-blue-600 text-white rounded text-sm">Cancel</button>
                        </div>
                      )}

                      {/* Round-by-round view with re-generate */}
                      {(() => {
                        const rounds = [...new Set(fixtures.map(f => f.round))].sort((a, b) => a - b);
                        return rounds.map(round => {
                          const roundFixtures = fixtures.filter(f => f.round === round).sort((a, b) => a.pitch - b.pitch);
                          return (
                            <div key={round} className="mb-6">
                              <div className="flex items-center justify-between mb-2">
                                <h3 className="text-lg font-bold text-gray-800">Round {round} - {roundFixtures[0]?.time}</h3>
                                <button
                                  onClick={() => regenerateRound(round)}
                                  disabled={loading}
                                  className="flex items-center gap-1 px-3 py-1 bg-amber-500 text-white rounded-lg text-sm hover:bg-amber-600 disabled:bg-gray-400"
                                >
                                  <RefreshCw size={14} className={loading ? 'animate-spin' : ''} />
                                  Re-generate
                                </button>
                              </div>
                              <div className="overflow-x-auto">
                                <table className="w-full">
                                  <thead className="bg-gray-50">
                                    <tr>
                                      <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">Pitch</th>
                                      <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">Zone</th>
                                      <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">Team 1</th>
                                      <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">Team 2</th>
                                      <th className="px-4 py-2 text-left text-sm font-medium text-gray-700">Referee</th>
                                      <th className="px-4 py-2 text-left text-sm font-medium text-gray-700 w-16">Swap</th>
                                    </tr>
                                  </thead>
                                  <tbody className="divide-y divide-gray-200">
                                    {roundFixtures.map(f => (
                                      <tr key={f.id} className={`hover:bg-gray-50 ${f.refereeConflict ? 'bg-red-50' : ''} ${swapMode && swapMode.fixtureId !== f.id && swapMode.round === round ? 'bg-blue-50/50' : ''}`}>
                                        <td className="px-4 py-2 text-sm font-medium">Pitch {f.pitch}</td>
                                        <td className="px-4 py-2 text-sm">
                                          {f.zone && <span className={f.isCrossZone ? 'text-amber-600 font-medium' : 'font-medium'}>Zone {f.zone}{f.isCrossZone ? ' *' : ''}</span>}
                                        </td>
                                        <td className="px-4 py-2 text-sm">
                                          {swapMode && swapMode.fixtureId !== f.id && swapMode.round === round ? (
                                            <button onClick={() => swapTeamsInFixture(f.id, f.team1.id)} className="text-blue-600 underline hover:text-blue-800">{f.team1.name}</button>
                                          ) : f.team1.name}
                                        </td>
                                        <td className="px-4 py-2 text-sm">
                                          {swapMode && swapMode.fixtureId !== f.id && swapMode.round === round ? (
                                            <button onClick={() => swapTeamsInFixture(f.id, f.team2.id)} className="text-blue-600 underline hover:text-blue-800">{f.team2.name}</button>
                                          ) : f.team2.name}
                                        </td>
                                        <td className="px-4 py-2 text-sm">
                                          {f.referee ? (
                                            <span className={f.refereeConflict ? 'text-red-600 font-medium' : 'text-green-700'}>
                                              {f.referee.name}{f.refereeConflict ? ' !' : ''}
                                            </span>
                                          ) : (
                                            <span className="text-red-500 font-medium">NONE</span>
                                          )}
                                        </td>
                                        <td className="px-4 py-2 text-sm">
                                          <div className="flex gap-1">
                                            <button
                                              onClick={() => setSwapMode({ fixtureId: f.id, slot: 1, teamName: f.team1.name, round })}
                                              className="px-1.5 py-0.5 bg-gray-200 text-gray-700 rounded text-xs hover:bg-gray-300"
                                              title={`Swap ${f.team1.name}`}
                                            >1</button>
                                            <button
                                              onClick={() => setSwapMode({ fixtureId: f.id, slot: 2, teamName: f.team2.name, round })}
                                              className="px-1.5 py-0.5 bg-gray-200 text-gray-700 rounded text-xs hover:bg-gray-300"
                                              title={`Swap ${f.team2.name}`}
                                            >2</button>
                                          </div>
                                        </td>
                                      </tr>
                                    ))}
                                  </tbody>
                                </table>
                              </div>
                            </div>
                          );
                        });
                      })()}
                    </div>
                  )}
                </div>
              </div>
            );
          }
           const { current, upcoming, allFixtures, outsideSchedule } = getCurrentAndNext();
          const teamFixtures = selectedTeam ? getTeamFixtures(selectedTeam.id) : [];

          return (
            <div className="min-h-screen bg-gradient-to-b from-green-50 to-white">
              <div className="bg-[#7c1229] text-white p-4 sticky top-0 z-10 shadow-lg">
                <div className="max-w-2xl mx-auto">
                  <div className="flex items-center justify-between mb-3">
                    <h1 className="text-2xl font-bold">U7's Waterfall</h1>
                    <button onClick={() => setShowSitePlan(true)} className="flex items-center gap-1.5 bg-white/20 hover:bg-white/30 px-3 py-1.5 rounded-lg transition-colors text-sm font-medium" aria-label="View site plan">
                      <MapPin size={18} />
                      <span>Site Map</span>
                    </button>
                  </div>
                  {selectedTeam ? (
                    <div className="flex items-center justify-between">
                      <button onClick={() => setSelectedTeam(null)} className="text-white/90 hover:text-white font-medium text-sm">â† Back to all fixtures</button>
                      <button onClick={() => downloadTeamFixturePDF(selectedTeam)} disabled={pdfLoading} className={`flex items-center gap-1.5 px-3 py-1.5 rounded-lg transition-colors text-sm font-medium ${pdfLoading ? 'bg-white/10 cursor-wait' : 'bg-white/20 hover:bg-white/30'}`}>
                        {pdfLoading ? <RefreshCw size={16} className="animate-spin" /> : <Download size={16} />}
                        <span>{pdfLoading ? 'Generating...' : 'Download PDF'}</span>
                      </button>
                    </div>
                  ) : (
                    <>
                      <div className="relative">
                        <Search className="absolute left-3 top-3 text-[#7c1229]" size={20} />
                        <input type="text" placeholder="Search for your team..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="w-full pl-10 pr-4 py-3 rounded-lg text-gray-900 text-lg" />
                      </div>
                      {searchTerm && (
                        <div className="mt-2 bg-white rounded-lg shadow-lg max-h-60 overflow-y-auto">
                          {filteredTeams.map(team => (
                            <button key={team.id} onClick={() => { setSelectedTeam(team); setSearchTerm(''); }} className="w-full px-4 py-3 text-left hover:bg-[#7c1229]/5 border-b border-gray-100 text-gray-900">
                              <div className="font-medium">{team.name}</div>
                              <div className="text-sm text-gray-600">Club: {team.club}</div>
                              {team.zone && <div className="text-sm text-[#7c1229] font-medium">Zone {team.zone}</div>}
                            </button>
                          ))}
                        </div>
                      )}
                    </>
                  )}
                </div>
              </div>
              {showSitePlan && (
                <div className="fixed inset-0 z-50 bg-black/70 flex items-center justify-center p-4" onClick={() => setShowSitePlan(false)} style={{touchAction: 'none'}}>
                  <div className="bg-white rounded-xl max-w-lg w-full max-h-[90vh] overflow-hidden shadow-2xl" onClick={(e) => e.stopPropagation()} onTouchMove={(e) => e.stopPropagation()}>
                    <div className="flex items-center justify-between p-4 border-b border-gray-200 bg-[#7c1229] text-white rounded-t-xl">
                      <h2 className="text-lg font-bold flex items-center gap-2">
                        <MapPin size={20} />
                        Site Plan
                      </h2>
                      <button onClick={() => setShowSitePlan(false)} className="p-1 hover:bg-white/20 rounded-lg transition-colors" aria-label="Close site plan">
                        <X size={24} />
                      </button>
                    </div>
                    <div className="overflow-auto" style={{WebkitOverflowScrolling: 'touch', overscrollBehavior: 'contain', touchAction: 'pan-x pan-y'}}>
                      <img src="site-plan.png" alt="Site plan showing 16 pitches in a 4x4 grid, colour-coded by zone A through H" style={{width: `${sitePlanZoom * 100}%`, height: 'auto', display: 'block'}} draggable="false" />
                    </div>
                    <div className="p-3 bg-gray-50 border-t border-gray-200 flex items-center justify-center gap-3">
                      <button onClick={() => setSitePlanZoom(z => Math.max(1, z - 0.5))} className="p-1.5 rounded-lg bg-gray-200 hover:bg-gray-300 transition-colors disabled:opacity-40" disabled={sitePlanZoom <= 1} aria-label="Zoom out">
                        <ZoomOut size={18} />
                      </button>
                      <span className="text-sm text-gray-500 min-w-[3rem] text-center">{Math.round(sitePlanZoom * 100)}%</span>
                      <button onClick={() => setSitePlanZoom(z => Math.min(3, z + 0.5))} className="p-1.5 rounded-lg bg-gray-200 hover:bg-gray-300 transition-colors disabled:opacity-40" disabled={sitePlanZoom >= 3} aria-label="Zoom in">
                        <ZoomIn size={18} />
                      </button>
                    </div>
                  </div>
                </div>
              )}
              <div className="max-w-2xl mx-auto p-4 pb-24">
                {fixtures.length === 0 ? (
                  <div className="bg-white rounded-lg shadow-lg p-8 text-center">
                    <Calendar size={48} className="mx-auto text-gray-400 mb-4" />
                    <h2 className="text-xl font-bold text-gray-900 mb-2">No Fixtures Yet</h2>
                    <p className="text-gray-600">Fixtures will appear here once generated by the admin.</p>
                  </div>
                ) : selectedTeam ? (
                  <div>
                    <div className="bg-white rounded-lg shadow-lg mb-4 overflow-hidden">
                      <div className="p-4">
                        <h2 className="text-xl font-bold text-gray-900">{selectedTeam.name}</h2>
                        <p className="text-gray-600">Club: {selectedTeam.club}</p>
                        {selectedTeam.zone && (
                          <p className="text-[#7c1229] font-semibold text-lg mt-1">
                            Zone {selectedTeam.zone} (Pitches {zones.find(z => z.id === selectedTeam.zone)?.pitches.join(' & ')})
                          </p>
                        )}
                        <p className="text-[#7c1229] font-medium mt-1">{teamFixtures.length} matches, {fixtures.filter(f => f.referee && f.referee.id === selectedTeam.id).length} ref duties</p>
                        {selectedTeam.zone && (() => {
                          const teamZone = zones.find(z => z.id === selectedTeam.zone);
                          if (!teamZone) return null;
                          const groupMembers = teamZone.teams.filter(t => t.id !== selectedTeam.id);
                          if (groupMembers.length === 0) return null;
                          return (
                            <div className="mt-2 pt-2 border-t border-gray-200">
                              <div className="flex items-center flex-wrap gap-1.5">
                                <span className="text-xs font-semibold text-gray-500">Group {selectedTeam.zone}:</span>
                                {groupMembers.map(t => (
                                  <span key={t.id} className="px-2 py-0.5 bg-[#7c1229]/10 text-[#7c1229] rounded-full text-xs font-medium">
                                    {t.name}
                                  </span>
                                ))}
                              </div>
                            </div>
                          );
                        })()}
                      </div>
                    </div>
                    <div className="space-y-3">
                      {(() => {
                        // Build combined schedule: matches + ref duties in time order
                        const refDuties = fixtures.filter(f => f.referee && f.referee.id === selectedTeam.id);
                        const schedule = [];
                        teamFixtures.forEach((f, idx) => {
                          const opponent = f.team1.id === selectedTeam.id ? f.team2 : f.team1;
                          schedule.push({ ...f, type: 'PLAY', opponent, matchNum: idx + 1 });
                        });
                        refDuties.forEach(f => {
                          schedule.push({ ...f, type: 'REF' });
                        });
                        schedule.sort((a, b) => a.time.localeCompare(b.time) || (a.type === 'PLAY' ? -1 : 1));

                        return schedule.map((item) => {
                          if (item.type === 'PLAY') {
                            const isAway = selectedTeam.zone && item.zone !== selectedTeam.zone;
                            return (
                              <div key={item.id + '-play'} className={`rounded-lg shadow p-4 ${isAway ? 'bg-amber-50 border-2 border-amber-400' : 'bg-white'}`}>
                                <div className="flex items-center justify-between mb-2">
                                  <span className="text-2xl font-bold text-[#7c1229]">{item.time}</span>
                                  <span className="text-lg font-medium text-gray-700">Match {item.matchNum}</span>
                                </div>
                                <div className="flex items-center gap-2 mb-2">
                                  <MapPin size={18} className={isAway ? 'text-amber-600' : 'text-gray-500'} />
                                  <span className="font-medium text-gray-900">Pitch {item.pitch}</span>
                                  {item.zone && (
                                    isAway ? (
                                      <span className="px-2 py-0.5 bg-amber-500 text-white rounded text-xs font-bold">
                                        AWAY - Zone {item.zone}
                                      </span>
                                    ) : (
                                      <span className="px-2 py-0.5 bg-[#7c1229]/10 text-[#7c1229] rounded text-xs font-medium">
                                        Zone {item.zone}
                                      </span>
                                    )
                                  )}
                                </div>
                                <div className="text-gray-700">
                                  <span className="font-medium">{item.team1.name}</span> <span className="text-gray-500">vs</span> <span className="font-medium">{item.team2.name}</span>
                                </div>
                                {item.referee && (
                                  <div className="text-xs text-gray-500 mt-1">Referee: {item.referee.name}</div>
                                )}
                              </div>
                            );
                          } else {
                            return (
                              <div key={item.id + '-ref'} title={`A coach from ${selectedTeam.name} is required to referee this match`} className={`rounded-lg shadow p-4 border-2 ${item.refereeConflict ? 'bg-red-50 border-red-400' : 'bg-blue-50 border-blue-400'}`}>
                                <div className="flex items-center justify-between mb-2">
                                  <span className="text-2xl font-bold text-gray-600">{item.time}</span>
                                  <span className={`px-2 py-0.5 rounded text-xs font-bold ${item.refereeConflict ? 'bg-red-500 text-white' : 'bg-blue-600 text-white'}`}>
                                    {item.refereeConflict ? 'REF DUTY - CONFLICT' : 'REF DUTY'}
                                  </span>
                                </div>
                                <div className="flex items-center gap-2 mb-2">
                                  <MapPin size={18} className="text-gray-500" />
                                  <span className="font-medium text-gray-900">Pitch {item.pitch}</span>
                                  {item.zone && (
                                    <span className="px-2 py-0.5 bg-gray-200 text-gray-700 rounded text-xs font-medium">
                                      Zone {item.zone}
                                    </span>
                                  )}
                                </div>
                                <div className="text-gray-700 text-sm">
                                  {item.team1.name} vs {item.team2.name}
                                </div>
                                <div className="text-xs text-blue-700 mt-1">Your coach is needed to referee this game</div>
                                {item.refereeConflict && (
                                  <div className="text-xs text-red-600 font-medium mt-1">Your team is also playing this round</div>
                                )}
                              </div>
                            );
                          }
                        });
                      })()}
                    </div>
                  </div>
                ) : (
                  <>
                    {outsideSchedule && (
                      <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg text-center">
                        <p className="text-blue-800 font-medium">No matches currently in progress - showing all fixtures</p>
                      </div>
                    )}
                    {current.length > 0 && (
                      <div className="mb-6">
                        <h2 className="text-xl font-bold text-gray-900 mb-3 flex items-center gap-2">
                          <div className="w-3 h-3 bg-red-500 rounded-full animate-pulse"></div>
                          Playing Now
                        </h2>
                        <div className="space-y-3">
                          {current.map(f => (
                            <div key={f.id} className="bg-white rounded-lg shadow-lg p-4 border-l-4 border-red-500">
                              <div className="flex items-center justify-between mb-2">
                                <span className="text-xl font-bold text-gray-900">{f.time}</span>
                                <span className="flex items-center gap-1 font-medium text-gray-700">
                                  <MapPin size={16} />
                                  Pitch {f.pitch}
                                  {f.zone && <span className="text-xs text-[#7c1229] ml-1">(Zone {f.zone})</span>}
                                </span>
                              </div>
                              <div className="text-gray-900">
                                <div className="font-medium">{f.team1.name}</div>
                                <div className="text-gray-500 text-sm my-1">vs</div>
                                <div className="font-medium">{f.team2.name}</div>
                              </div>
                              {f.referee && (
                                <div className={`text-xs mt-2 ${f.refereeConflict ? 'text-red-600 font-medium' : 'text-gray-500'}`}>
                                  Ref: {f.referee.name}{f.refereeConflict ? ' (conflict)' : ''}
                                </div>
                              )}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                    {upcoming.length > 0 && (
                      <div>
                        <h2 className="text-xl font-bold text-gray-900 mb-3">Up Next</h2>
                        <div className="space-y-3">
                          {upcoming.map(f => (
                            <div key={f.id} className="bg-white rounded-lg shadow p-4">
                              <div className="flex items-center justify-between mb-2">
                                <span className="text-xl font-bold text-[#7c1229]">{f.time}</span>
                                <span className="flex items-center gap-1 font-medium text-gray-700">
                                  <MapPin size={16} />
                                  Pitch {f.pitch}
                                  {f.zone && <span className="text-xs text-[#7c1229] ml-1">(Zone {f.zone})</span>}
                                </span>
                              </div>
                              <div className="text-gray-900 text-sm">
                                <div>{f.team1.name}</div>
                                <div className="text-gray-500 my-1">vs</div>
                                <div>{f.team2.name}</div>
                              </div>
                              {f.referee && (
                                <div className={`text-xs mt-1 ${f.refereeConflict ? 'text-red-600 font-medium' : 'text-gray-400'}`}>
                                  Ref: {f.referee.name}{f.refereeConflict ? ' (conflict)' : ''}
                                </div>
                              )}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                    {outsideSchedule && allFixtures.length > 0 && (
                      <div>
                        <h2 className="text-xl font-bold text-gray-900 mb-3">All Fixtures</h2>
                        <div className="space-y-3">
                          {allFixtures.map(f => (
                            <div key={f.id} className="bg-white rounded-lg shadow p-4">
                              <div className="flex items-center justify-between mb-2">
                                <span className="text-xl font-bold text-[#7c1229]">{f.time}</span>
                                <span className="flex items-center gap-1 font-medium text-gray-700">
                                  <MapPin size={16} />
                                  Pitch {f.pitch}
                                  {f.zone && <span className="text-xs text-[#7c1229] ml-1">(Zone {f.zone})</span>}
                                </span>
                              </div>
                              <div className="text-gray-900 text-sm">
                                <div>{f.team1.name}</div>
                                <div className="text-gray-500 my-1">vs</div>
                                <div>{f.team2.name}</div>
                              </div>
                              {f.referee && (
                                <div className={`text-xs mt-1 ${f.refereeConflict ? 'text-red-600 font-medium' : 'text-gray-400'}`}>
                                  Ref: {f.referee.name}{f.refereeConflict ? ' (conflict)' : ''}
                                </div>
                              )}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </>
                )}
              </div>
            </div>
          );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<RugbyFixtureApp />);
    </script>
</body>
</html>


